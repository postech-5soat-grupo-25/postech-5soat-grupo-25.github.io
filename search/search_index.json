{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>O objetivo desse site \u00e9 centralizar todas as documenta\u00e7\u00f5es dos entreg\u00e1veis constru\u00eddos para o Tech Challenge da P\u00f3s-Gradua\u00e7\u00e3o em Software Architecture da FIAP. </p> <p>Cada fase est\u00e1 estruturada como uma aba do site e cada entreg\u00e1vel como uma se\u00e7\u00e3o da respectiva aba. Estamos organizando as tarefas atrav\u00e9s do board no GitHub e utilizamos um board no Miro para as din\u00e2micas de idea\u00e7\u00e3o.</p> Membros do Grupo RM Alan Marques Molina <code>353062</code> Albert Dias Moreira <code>352569</code> Bruno Mafra Pelence <code>352939</code> Lucas Felipe Rebello <code>352982</code> Matheus Bachiste Lopes <code>352783</code>"},{"location":"fase_1/entregavel_1/","title":"Entreg\u00e1vel 1","text":""},{"location":"fase_1/entregavel_1/#domain-driven-design","title":"Domain-Driven Design","text":""},{"location":"fase_1/entregavel_1/#glossario-da-linguagem-ubiqua","title":"Gloss\u00e1rio da Linguagem Ub\u00edqua","text":"<p>A comunica\u00e7\u00e3o clara e eficaz \u00e9 um pilar fundamental no desenvolvimento de sistemas complexos, especialmente quando se trata de traduzir as necessidades do neg\u00f3cio em solu\u00e7\u00f5es tecnol\u00f3gicas. No contexto do projeto de autoatendimento para a lanchonete, \u00e9 essencial estabelecer uma linguagem comum que seja compreendida por todos os envolvidos, desde a equipe de desenvolvimento at\u00e9 os funcion\u00e1rios e clientes do estabelecimento.</p> <p>Para alcan\u00e7ar esse objetivo, adotamos o conceito de Linguagem Ub\u00edqua do Domain-Driven Design (DDD), criado por Eric Evans. Esta linguagem ub\u00edqua serve como uma ponte entre o dom\u00ednio do neg\u00f3cio e o modelo t\u00e9cnico, garantindo que todos os termos e conceitos sejam usados de forma consistente e sem ambiguidades.</p> <p>O gloss\u00e1rio a seguir \u00e9 uma compila\u00e7\u00e3o dos termos-chave que formam a base da nossa linguagem ub\u00edqua. Ele serve como uma refer\u00eancia r\u00e1pida para entender os elementos e processos que comp\u00f5em o sistema de autoatendimento da lanchonete, assegurando que a comunica\u00e7\u00e3o seja precisa e alinhada com as necessidades\u00a0do\u00a0projeto.</p> <ul> <li>Pedido: Uma solicita\u00e7\u00e3o feita por um cliente para produtos espec\u00edficos, que pode incluir um lanche, acompanhamento, bebida e/ou sobremesa.</li> <li>Cliente: A pessoa que faz um pedido na lanchonete. Pode ser identificado por CPF, nome, e-mail ou permanecer an\u00f4nimo.</li> <li>Cozinha: Conjunto de funcion\u00e1rios respons\u00e1veis pela prepara\u00e7\u00e3o dos produtos que comp\u00f5em um pedido trabalhando em conjunto em um espa\u00e7o f\u00edsico designado.</li> <li>Produto: Cada um dos itens do menu que podem ser selecionados para compor um pedido. Todo produto possui um nome, uma descri\u00e7\u00e3o e um pre\u00e7o.</li> <li>Categoria: Classifica\u00e7\u00e3o do produto. Pode ser Lanche, Acompanhamento, Bebida ou Sobremesa:<ul> <li>Lanche: Um produto de menu principal que pode ser personalizado com ingredientes espec\u00edficos.</li> <li>Acompanhamento: Um produto adicional que complementa o lanche, como batatas fritas.</li> <li>Bebida: Uma bebida que acompanha o lanche e o acompanhamento.</li> <li>Sobremesa: Um produto de menu doce servido ap\u00f3s a refei\u00e7\u00e3o principal.</li> </ul> </li> <li>Combo: Uma combina\u00e7\u00e3o de produtos de menu selecionados pelo cliente, geralmente incluindo um lanche principal, acompanhamento e bebida.</li> <li>Menu: Conjunto de produtos organizados por categorias que podem ser selecionados para compor um pedido.</li> <li>Sistema de Autoatendimento: Uma solu\u00e7\u00e3o tecnol\u00f3gica que permite aos clientes fazer pedidos e pagamentos por meio de uma interface digital sem a necessidade de intera\u00e7\u00e3o direta com atendentes.</li> <li>Monitor de Acompanhamento: Dispositivo que exibe o progresso do pedido para o cliente, com etapas como Recebido, Em prepara\u00e7\u00e3o, Pronto e Finalizado:<ul> <li>Recebido: O status inicial de um pedido ap\u00f3s ser submetido pelo cliente, indicando que o pedido foi recebido pelo sistema e est\u00e1 aguardando para ser processado.</li> <li>Em Prepara\u00e7\u00e3o: O status de um pedido que est\u00e1 sendo preparado pela cozinha. Nesta etapa, os ingredientes est\u00e3o sendo montados e o pedido est\u00e1 em processo de ser conclu\u00eddo.</li> <li>Pronto: O status que indica que o pedido foi preparado e est\u00e1 pronto para ser entregue ou retirado pelo cliente.</li> <li>Finalizado: O status final de um pedido, que ocorre ap\u00f3s o cliente retirar o pedido. Indica que o ciclo do pedido foi completado e que n\u00e3o h\u00e1 mais a\u00e7\u00f5es pendentes.</li> </ul> </li> <li>Usu\u00e1rio: Funcion\u00e1rio do estabelecimento com acesso \u00e0 interface ou portal para gerenciamento de clientes, produtos, categorias e acompanhamento de pedidos.</li> <li>Acesso Administrativo: Interface ou portal que permite ao estabelecimento gerenciar clientes, produtos, categorias e acompanhar pedidos.</li> <li>Campanhas Promocionais: Estrat\u00e9gias de marketing para incentivar vendas ou fidelizar clientes, utilizando a identifica\u00e7\u00e3o dos mesmos.</li> </ul>"},{"location":"fase_1/entregavel_1/#tecnias-de-modelagem-de-dominio","title":"T\u00e9cnias de Modelagem de Dom\u00ednio","text":"<p>Para garantir uma compreens\u00e3o profunda e compartilhada dos processos cr\u00edticos do nosso sistema de autoatendimento, utilizamos t\u00e9cnicas colaborativas de modelagem de dom\u00ednio: o Domain Storytelling e o Event Storming. Essas t\u00e9cnicas nos permitem visualizar e explorar os fluxos de neg\u00f3cio, capturando a ess\u00eancia das intera\u00e7\u00f5es e eventos que ocorrem durante a realiza\u00e7\u00e3o de pedidos e pagamentos, bem como a prepara\u00e7\u00e3o e entrega dos pedidos.</p> <p>Os diagramas a seguir representam os fluxos de Realiza\u00e7\u00e3o do Pedido e Pagamento e Prepara\u00e7\u00e3o e Entrega do Pedido. Eles s\u00e3o essenciais para entender as opera\u00e7\u00f5es do sistema de autoatendimento e para identificar oportunidades de melhoria e pontos de integra\u00e7\u00e3o. Esses modelos visuais s\u00e3o ferramentas poderosas para alinhar a equipe de desenvolvimento com as expectativas do neg\u00f3cio e para garantir que o sistema final atenda \u00e0s necessidades dos usu\u00e1rios finais de forma eficiente\u00a0e\u00a0eficaz.</p>"},{"location":"fase_1/entregavel_1/#domain-storytelling","title":"Domain Storytelling","text":"<p>O Domain Storytelling nos ajuda a contar a hist\u00f3ria do nosso dom\u00ednio. Atrav\u00e9s de simples ilustra\u00e7\u00f5es e narrativas, conseguimos mapear como os diferentes atores interagem com o sistema e entre si, criando uma vis\u00e3o clara e compartilhada das funcionalidades e processos do neg\u00f3cio.</p> <p> </p> Realiza\u00e7\u00e3o de pedido e pagamento <p> </p> Prepara\u00e7\u00e3o e entrega do pedido"},{"location":"fase_1/entregavel_1/#event-storming","title":"Event Storming","text":"<p>O Event Storming \u00e9 uma t\u00e9cnica de modelagem r\u00e1pida e interativa que re\u00fane diferentes stakeholders para explorar fluxos de trabalho e processos de neg\u00f3cio. Ao identificar eventos, comandos, pol\u00edticas e agregados, criamos uma representa\u00e7\u00e3o visual din\u00e2mica que destaca as rea\u00e7\u00f5es em cadeia e os pontos cr\u00edticos do sistema.</p> <p> </p> Realiza\u00e7\u00e3o de pedido e pagamento <p> </p> Prepara\u00e7\u00e3o e entrega do pedido <p> </p> Organiza\u00e7\u00e3o e identifica\u00e7\u00e3o dos agregados"},{"location":"fase_1/entregavel_1/#entidades-e-objetos-de-valor","title":"Entidades e Objetos de Valor","text":""},{"location":"fase_1/entregavel_1/#entidades","title":"Entidades","text":"<ul> <li>Usu\u00e1rio</li> </ul> Propriedade Tipo Descri\u00e7\u00e3o id <code>usize</code> Identificador \u00fanico do usu\u00e1rio. nome <code>String</code> Nome do usu\u00e1rio. email <code>String</code> E-mail do usu\u00e1rio. cpf <code>Cpf</code> CPF do usu\u00e1rio (objeto de valor). tipo <code>Tipo</code> Tipo de acesso do usu\u00e1rio (Admin ou Cozinha) status <code>Status</code> Status de acesso do usu\u00e1rio (Ativo ou Inativo) data_criacao <code>String</code> Data de cria\u00e7\u00e3o do registro do usu\u00e1rio. data_atualizacao <code>String</code> Data de atualiza\u00e7\u00e3o do registro do usu\u00e1rio. <ul> <li>Cliente</li> </ul> Propriedade Tipo Descri\u00e7\u00e3o id <code>usize</code> Identificador \u00fanico do cliente. nome <code>String</code> Nome do cliente. email <code>String</code> E-mail do cliente. cpf <code>Cpf</code> CPF do cliente (objeto de valor). data_criacao <code>String</code> Data de cria\u00e7\u00e3o do registro do cliente. data_atualizacao <code>String</code> Data de atualiza\u00e7\u00e3o do registro do cliente. <ul> <li>Produto</li> </ul> Propriedade Tipo Descri\u00e7\u00e3o id <code>usize</code> Identificador \u00fanico do produto. nome <code>String</code> Nome do produto. foto <code>String</code> Caminho ou URL da foto do produto. descricao <code>String</code> Descri\u00e7\u00e3o do produto. categoria <code>Categoria</code> Categoria do produto (Lanche, Acompanhamento, Bebida ou Sobremesa). preco <code>f32</code> Pre\u00e7o do produto. ingredientes <code>Ingredientes</code> Ingredientes do produto (objeto de valor). data_criacao <code>String</code> Data de cria\u00e7\u00e3o do registro do produto. data_atualizacao <code>String</code> Data de atualiza\u00e7\u00e3o do registro do produto. <ul> <li>Pedido</li> </ul> <p>Agregado entre Cliente e Produto</p> Propriedade Tipo Descri\u00e7\u00e3o id <code>usize</code> Identificador \u00fanico do pedido. cliente <code>Cliente</code> Cliente que fez o pedido. lanche <code>Produto</code> Produto do tipo lanche no pedido. acompanhamento <code>Produto</code> Produto do tipo acompanhamento no pedido. bebida <code>Produto</code> Produto do tipo bebida no pedido. pagamento <code>String</code> Informa\u00e7\u00e3o de pagamento do pedido. status <code>Status</code> Status atual do pedido (Recebido, Em Prepara\u00e7\u00e3o, Pronto ou Finalizado). data_criacao <code>String</code> Data de cria\u00e7\u00e3o do registro do pedido. data_atualizacao <code>String</code> Data de atualiza\u00e7\u00e3o do registro do pedido."},{"location":"fase_1/entregavel_1/#objetos-de-valor","title":"Objetos de Valor","text":"<ul> <li>CPF</li> </ul> Propriedade Tipo Descri\u00e7\u00e3o codigo <code>String</code> N\u00famero do CPF. <ul> <li>Ingredientes</li> </ul> Propriedade Tipo Descri\u00e7\u00e3o ingredientes <code>Vec&lt;String&gt;</code> Lista de ingredientes do produto."},{"location":"fase_1/entregavel_2/","title":"Entreg\u00e1vel 2","text":"<p>Qual linguagem estamos utilizando?</p> <p>Escolhemos o Rust como linguagem de programa\u00e7\u00e3o para o desenvolvimento do sistema. Essa escolha foi motivada inicialmente pelo interesse do grupo em aprender uma linguagem moderna e que tem ganhado destaque no cen\u00e1rio de desenvolvimento. </p> <p>Rust \u00e9 uma linguagem que evita erros comuns em sistemas de baixo n\u00edvel e oferece ferramentas modernas para lidar com concorr\u00eancia. Al\u00e9m disso, Rust proporciona um ambiente de desenvolvimento produtivo com um gerenciador de pacotes e um sistema de build integrados, al\u00e9m de uma comunidade ativa e em expans\u00e3o. </p> <p>Em resumo, a escolha do Rust para o desenvolvimento do sistema de autoatendimento da lanchonete se alinha com os objetivos de criar uma aplica\u00e7\u00e3o segura, eficiente e f\u00e1cil de manter, ao mesmo tempo que proporciona uma oportunidade valiosa de aprendizado para a equipe de desenvolvimento.</p> <p>Qual banco de dados estamos utilizando?</p> <p>Para o armazenamento de dados do nosso sistema, optamos pelo PostgreSQL, um sistema de gerenciamento de banco de dados relacional de c\u00f3digo aberto. A decis\u00e3o de usar o PostgreSQL foi baseada em sua robustez, confiabilidade e rica funcionalidade, que o tornam adequado para uma ampla gama de aplica\u00e7\u00f5es, desde pequenos projetos at\u00e9 solu\u00e7\u00f5es empresariais complexas.</p> <p>Esse banco oferece a capacidade de lidar com um volume significativo de transa\u00e7\u00f5es e a flexibilidade para se adaptar \u00e0s mudan\u00e7as nos requisitos de neg\u00f3cios, que s\u00e3o requisitos fundamentais para o sucesso do projeto.</p> <p>Em resumo, o PostgreSQL se encaixa perfeitamente em nossa solu\u00e7\u00e3o, fornecendo uma base de dados confi\u00e1vel e eficiente que nos permite construir um sistema de autoatendimento robusto e capaz de crescer junto com o neg\u00f3cio.</p>"},{"location":"fase_1/entregavel_2/#arquitetura-hegaxonal","title":"Arquitetura Hegaxonal","text":"<p>A Arquitetura Hexagonal, tamb\u00e9m conhecida como Ports &amp; Adapters, \u00e9 um padr\u00e3o de design que visa separar a l\u00f3gica de neg\u00f3cios de uma aplica\u00e7\u00e3o das tecnologias utilizadas para entrar ou sair do sistema. Na Arquitetura Hexagonal, a aplica\u00e7\u00e3o \u00e9 centralizada em torno do dom\u00ednio do neg\u00f3cio, que \u00e9 cercado por portas (ports) que definem os pontos de intera\u00e7\u00e3o com servi\u00e7os externos ou com o usu\u00e1rio. Adaptadores (adapters) s\u00e3o implementados para se conectarem a essas portas, permitindo que a aplica\u00e7\u00e3o se comunique com diferentes tipos de tecnologias e interfaces sem que haja impacto na l\u00f3gica central do neg\u00f3cio.</p> <p>A utiliza\u00e7\u00e3o da arquitetura hexagonal no sistema de autoatendimento oferece diversos benef\u00edcios, especialmente considerando que estamos desenvolvendo, a princ\u00edpio, um backend monol\u00edtico:</p> <ul> <li>Flexibilidade: Permite que mudan\u00e7as em tecnologias externas, como bancos de dados ou servi\u00e7os de terceiros, sejam feitas com m\u00ednimo impacto na l\u00f3gica central do neg\u00f3cio;</li> <li>Testabilidade: Facilita a cria\u00e7\u00e3o de testes automatizados, pois os adapters podem ser substitu\u00eddos por vers\u00f5es de teste que simulam comportamentos espec\u00edficos;</li> <li>Manutenibilidade: A clareza na separa\u00e7\u00e3o de responsabilidades torna o c\u00f3digo mais organizado e f\u00e1cil de entender, o que simplifica a manuten\u00e7\u00e3o e a evolu\u00e7\u00e3o do sistema;</li> <li>Escalabilidade: Embora o projeto comece como um monolito, a arquitetura hexagonal permite uma transi\u00e7\u00e3o mais suave para uma arquitetura limpa ou de microservi\u00e7os no futuro.</li> </ul>"},{"location":"fase_1/entregavel_2/#estrutura-de-diretorios","title":"Estrutura de Diret\u00f3rios","text":"<p>A estrutura de diret\u00f3rios do projeto reflete a aplica\u00e7\u00e3o da Arquitetura Hexagonal combinada com os princ\u00edpios do Domain-Driven Design. Ela foi projetada de modo a suportar a organiza\u00e7\u00e3o do c\u00f3digo e a separa\u00e7\u00e3o de responsabilidades.</p> <pre><code>\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 adapter\n\u2502   \u2502   \u251c\u2500\u2500 api\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 controllers\n\u2502   \u2502   \u251c\u2500\u2500 driven\n\u2502   \u2502   \u2514\u2500\u2500 driver\n\u2502   \u251c\u2500\u2500 core\n\u2502   \u2502   \u251c\u2500\u2500 application\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 ports\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 use_cases\n\u2502   \u2502   \u2514\u2500\u2500 domain\n\u2502   \u2502       \u251c\u2500\u2500 entities\n\u2502   \u2502       \u2514\u2500\u2500 value_objects\n</code></pre> <ul> <li><code>src/</code>: Raiz do c\u00f3digo fonte do projeto, onde toda a l\u00f3gica da aplica\u00e7\u00e3o reside.<ul> <li><code>adapter/</code>: Cont\u00e9m os adaptadores da Arquitetura Hexagonal, divididos em categorias:<ul> <li><code>driven/</code>: Adapters que o dom\u00ednio \"dirige\", como a infraestrutura de persist\u00eancia e integra\u00e7\u00f5es com sistemas de pagamento.</li> <li><code>driver/</code>: Cont\u00e9m os adapters que iniciam a\u00e7\u00f5es (ou \"dirigem\") no dom\u00ednio, como interfaces de linhas de comando.</li> <li><code>api/</code>: Adapters relacionados \u00e0 interface de usu\u00e1rio, como controladores que lidam com requisi\u00e7\u00f5es HTTP e autentica\u00e7\u00e3o.</li> </ul> </li> <li><code>core/</code>: N\u00facleo do dom\u00ednio da aplica\u00e7\u00e3o, onde a l\u00f3gica de neg\u00f3cios \u00e9 implementada seguindo os princ\u00edpios do DDD:<ul> <li><code>domain/</code>: Cont\u00e9m as entidades, objetos de valor e reposit\u00f3rios que formam o modelo de dom\u00ednio.</li> <li><code>application/</code>: Inclui os casos de uso que orquestram o fluxo de neg\u00f3cios e as interfaces que definem como o dom\u00ednio interage com os adaptadores.</li> </ul> </li> </ul> </li> </ul>"},{"location":"fase_1/entregavel_2/#frameworks-e-bibliotecas","title":"Frameworks e Bibliotecas","text":"<p>Dentre os pacotes que estamos utilizando para a constru\u00e7\u00e3o da aplica\u00e7\u00e3o, destacamos o Rocket para web e o Tokio Postgres para integra\u00e7\u00e3o com o banco de dados. A combina\u00e7\u00e3o dessas ferramentas nos fornece uma base s\u00f3lida e perform\u00e1tica para estruturar a arquitetura do nosso sistema. Abaixo, elencamos mais alguns detalhes da nossa escolha.</p>"},{"location":"fase_1/entregavel_2/#rocket","title":"Rocket","text":"<p>Rocket \u00e9 um framework web para Rust que facilita a escrita de aplica\u00e7\u00f5es web r\u00e1pidas e seguras sem sacrificar a flexibilidade. Ele \u00e9 conhecido por sua simplicidade e ergonomia, oferecendo uma experi\u00eancia de desenvolvimento agrad\u00e1vel e produtiva. Rocket fornece uma s\u00e9rie de funcionalidades prontas para uso, como roteamento, gerenciamento de estado, tratamento de requisi\u00e7\u00f5es e respostas, e suporte a middlewares.</p> <p>Escolhemos o Rocket para o nosso sistema de autoatendimento por v\u00e1rias raz\u00f5es:</p> <ul> <li>Simplicidade e Expressividade: Rocket permite definir rotas e handlers de forma declarativa, tornando o c\u00f3digo f\u00e1cil de escrever e entender;</li> <li>Seguran\u00e7a: Rocket encoraja pr\u00e1ticas seguras de programa\u00e7\u00e3o e gerencia muitos aspectos de seguran\u00e7a web automaticamente;</li> <li>Extensibilidade: Rocket \u00e9 altamente personaliz\u00e1vel e extens\u00edvel, permitindo que a equipe adapte o framework \u00e0s necessidades espec\u00edficas do projeto;</li> <li>Comunidade e Suporte: Rocket tem uma comunidade ativa e um ecossistema crescente, com suporte a muitas crates que podem ser integradas para expandir a funcionalidade da aplica\u00e7\u00e3o.</li> </ul>"},{"location":"fase_1/entregavel_2/#tokio-postgres","title":"Tokio Postgres","text":"<p>Tokio Postgres \u00e9 uma biblioteca ass\u00edncrona para intera\u00e7\u00e3o com bancos de dados PostgreSQL em Rust. Ela \u00e9 constru\u00edda sobre o Tokio, um runtime ass\u00edncrono para a linguagem Rust, que permite a execu\u00e7\u00e3o de opera\u00e7\u00f5es de entrada/sa\u00edda (I/O) de forma n\u00e3o bloqueante e eficiente.</p> <p>Optamos pelo Tokio Postgres devido \u00e0s seguintes caracter\u00edsticas:</p> <ul> <li>Assincronia: Aproveitamos o modelo ass\u00edncrono do Tokio para realizar opera\u00e7\u00f5es de banco de dados sem bloquear a execu\u00e7\u00e3o, melhorando a capacidade de resposta e a escalabilidade do sistema;</li> <li>Integra\u00e7\u00e3o com Tokio: Como o Tokio \u00e9 uma escolha comum para aplica\u00e7\u00f5es ass\u00edncronas em Rust, a integra\u00e7\u00e3o com Tokio Postgres \u00e9 natural e bem suportada;</li> <li>Tipagem Forte: A biblioteca se beneficia do sistema de tipos do Rust para garantir que as intera\u00e7\u00f5es com o banco de dados sejam seguras e corretas em tempo de compila\u00e7\u00e3o.</li> </ul>"},{"location":"fase_1/entregavel_3/","title":"Entreg\u00e1vel 3","text":""},{"location":"fase_1/entregavel_3/#dockerfile","title":"Dockerfile","text":"<p>O Dockerfile \u00e9 um script de configura\u00e7\u00e3o que cont\u00e9m uma s\u00e9rie de instru\u00e7\u00f5es para criar uma imagem Docker para a aplica\u00e7\u00e3o. A utiliza\u00e7\u00e3o de um Dockerfile permite a automa\u00e7\u00e3o do processo de constru\u00e7\u00e3o da imagem, garantindo que a aplica\u00e7\u00e3o seja empacotada com todas as suas depend\u00eancias e pronta para ser executada em qualquer ambiente Docker.</p> <p>O Dockerfile cria uma imagem Docker leve e eficiente para a aplica\u00e7\u00e3o, utilizando a imagem <code>rust:1.75-alpine3.19</code> como base para o est\u00e1gio de constru\u00e7\u00e3o e uma imagem <code>scratch</code> para o est\u00e1gio de produ\u00e7\u00e3o.</p>"},{"location":"fase_1/entregavel_3/#estagio-de-construcao","title":"Est\u00e1gio de Constru\u00e7\u00e3o","text":"<ul> <li>A imagem base <code>rust:1.75-alpine3.19</code> \u00e9 uma vers\u00e3o minimalista que reduz o tamanho do container;</li> <li>O Rust \u00e9 configurado para a vers\u00e3o <code>nightly</code> para utilizar features espec\u00edficas dessa vers\u00e3o;</li> <li>O diret\u00f3rio de trabalho \u00e9 definido como <code>/usr/src/tech-challenge</code>;</li> <li>A depend\u00eancia <code>musl-dev</code> \u00e9 instalada para permitir a compila\u00e7\u00e3o est\u00e1tica do bin\u00e1rio;</li> <li>O c\u00f3digo fonte \u00e9 copiado para o container e o projeto \u00e9 constru\u00eddo com <code>cargo build --release</code>.</li> </ul>"},{"location":"fase_1/entregavel_3/#estagio-de-producao","title":"Est\u00e1gio de Produ\u00e7\u00e3o","text":"<ul> <li>A imagem <code>scratch</code> \u00e9 usada como base, que \u00e9 uma imagem vazia, para manter o container o mais leve poss\u00edvel;</li> <li>O bin\u00e1rio compilado \u00e9 copiado do est\u00e1gio de constru\u00e7\u00e3o;</li> <li>O ponto de entrada \u00e9 definido para executar o bin\u00e1rio;</li> <li>A porta <code>3000</code> \u00e9 exposta para comunica\u00e7\u00e3o com o container.</li> </ul>"},{"location":"fase_1/entregavel_3/#docker-compose","title":"Docker Compose","text":"<p>O Docker Compose define como os servi\u00e7os Docker devem ser executados e como eles interagem entre si. Com o Docker Compose, podemos definir uma aplica\u00e7\u00e3o multi-cont\u00eainer de forma declarativa e gerenciar todo o ciclo de vida da aplica\u00e7\u00e3o com comandos simples.</p> <p>Nosso arquivo de configura\u00e7\u00e3o <code>docker-compose.yml</code> define dois servi\u00e7os: app (aplica\u00e7\u00e3o) e db (banco de dados).</p>"},{"location":"fase_1/entregavel_3/#servico-de-aplicacao","title":"Servi\u00e7o de Aplica\u00e7\u00e3o","text":"<ul> <li>Constr\u00f3i a imagem da aplica\u00e7\u00e3o a partir do Dockerfile descrito anteriormente;</li> <li>Reinicia automaticamente sempre que h\u00e1 uma falha;</li> <li>Mapeia a porta <code>8080</code> do host para a porta <code>3000</code> do container;</li> <li>Define a depend\u00eancia no servi\u00e7o <code>db</code>;</li> <li>Utiliza um arquivo <code>.env</code> para carregar vari\u00e1veis de ambiente;</li> <li>Define vari\u00e1veis de ambiente adicionais para a conex\u00e3o com o banco de dados e outras configura\u00e7\u00f5es.</li> </ul>"},{"location":"fase_1/entregavel_3/#servico-de-banco-de-dados","title":"Servi\u00e7o de Banco de Dados","text":"<ul> <li>Utiliza a imagem <code>postgres:15.2-alpine</code>;</li> <li>Reinicia automaticamente sempre que h\u00e1 uma falha;</li> <li>Define vari\u00e1veis de ambiente para a configura\u00e7\u00e3o do PostgreSQL;</li> <li>Mapeia a porta <code>5432</code> do host para a porta <code>5432</code> do container.</li> </ul>"},{"location":"fase_1/entregavel_3/#tutorial-para-execucao-da-aplicacao-com-docker","title":"Tutorial para Execu\u00e7\u00e3o da Aplica\u00e7\u00e3o com Docker","text":"<p>1. Clonar o Reposit\u00f3rio</p> <p>Fa\u00e7a o clone do reposit\u00f3rio abaixo e entre no diret\u00f3rio do projeto:</p> <pre><code>git clone git@github.com:postech-5soat-grupo-25/tech_challenge.git\ncd tech_challenge\n</code></pre> <p>2. Construir a Imagem Docker</p> <p>Execute <code>make build</code> para construir a imagem Docker da aplica\u00e7\u00e3o. Isso tamb\u00e9m construir\u00e1 a imagem do banco de dados se necess\u00e1rio.</p> <p>3. Iniciar a Aplica\u00e7\u00e3o</p> <p>Ap\u00f3s a constru\u00e7\u00e3o, execute <code>make run</code> para iniciar a aplica\u00e7\u00e3o. Isso iniciar\u00e1 tanto o servi\u00e7o da aplica\u00e7\u00e3o quanto o servi\u00e7o do banco de dados.</p> <p>4. Acessar a Aplica\u00e7\u00e3o</p> <p>Com a aplica\u00e7\u00e3o em execu\u00e7\u00e3o, voc\u00ea pode acess\u00e1-la atrav\u00e9s do localhost:8080 no seu navegador ou utilizando um cliente HTTP. Nessa etapa voc\u00ea pode interagir com a aplica\u00e7\u00e3o utilizando os endpoints descritos no Entreg\u00e1vel 2 e acessar a Swagger UI disponibilizada.</p> <p>5. Desligar a Aplica\u00e7\u00e3o</p> <p>Quando terminar, execute <code>make down</code> para desligar a aplica\u00e7\u00e3o e remover os containers.</p>"},{"location":"fase_2/entregavel_1/","title":"Entreg\u00e1vel 1","text":""},{"location":"fase_2/entregavel_1/#clean-architecture-e-clean-code","title":"Clean Architecture e Clean Code","text":"<p>A Clean Architecture, proposta por Robert C. Martin (o Uncle Bob), \u00e9 uma abordagem de design de software que visa separar as preocupa\u00e7\u00f5es do c\u00f3digo em camadas distintas, promovendo a independ\u00eancia do dom\u00ednio de neg\u00f3cios em rela\u00e7\u00e3o a frameworks, interfaces de usu\u00e1rio, e qualquer agente externo. O objetivo \u00e9 criar sistemas mais male\u00e1veis, test\u00e1veis e independentes de tecnologias externas, facilitando a manuten\u00e7\u00e3o e a evolu\u00e7\u00e3o do software. O Clean Code \u00e9 um conjunto de pr\u00e1ticas para escrever c\u00f3digo que seja f\u00e1cil de entender e modificar. Um c\u00f3digo limpo deve ser claro, simples, e direto, com nomes de vari\u00e1veis e fun\u00e7\u00f5es que revelam sua inten\u00e7\u00e3o, al\u00e9m de estar bem organizado e ser facilmente leg\u00edvel por outros desenvolvedores.</p>"},{"location":"fase_2/entregavel_1/#ports-adapters-x-clean-architecture","title":"Ports &amp; Adapters x Clean Architecture","text":"<p>A Arquitetura Hexagonal (ou Ports &amp; Adapters), utilizada na Fase 1 do projeto, foca na separa\u00e7\u00e3o da l\u00f3gica de aplica\u00e7\u00e3o do mundo exterior, permitindo que a aplica\u00e7\u00e3o interaja com diferentes tecnologias de entrada e sa\u00edda atrav\u00e9s de portas e adaptadores. </p> <p>Agora, a ideia \u00e9 converter a aplica\u00e7\u00e3o para utilizar os conceitos de Clean Architecture. Ambas as arquiteturas visam a separa\u00e7\u00e3o de preocupa\u00e7\u00f5es e a independ\u00eancia de tecnologias externas. A principal diferen\u00e7a entre elas \u00e9 que a Clean Architecture enfatiza ainda mais a separa\u00e7\u00e3o e a independ\u00eancia, organizando o c\u00f3digo em camadas circulares, onde as depend\u00eancias apontam para dentro, em dire\u00e7\u00e3o \u00e0 l\u00f3gica de neg\u00f3cios central. Isso promove uma maior flexibilidade e desacoplamento entre os componentes do sistema.</p>"},{"location":"fase_2/entregavel_1/#conversao-para-clean-architecture","title":"Convers\u00e3o para Clean Architecture","text":"<p>Para convers\u00e3o entre as arquiteturas, atualizamos a estrutura de diret\u00f3rios para refletir a separa\u00e7\u00e3o de responsabilidades conforme os princ\u00edpios da Clean Architecture:</p> <ul> <li>Entities (<code>entities</code>): Representam os objetos de dom\u00ednio do neg\u00f3cio, que s\u00e3o independentes de qualquer framework ou banco de dados.</li> <li>Use Cases (<code>use_cases</code>): Cont\u00eam a l\u00f3gica de neg\u00f3cios espec\u00edfica da aplica\u00e7\u00e3o, coordenando o fluxo de dados entre as entidades e os gateways.</li> <li>Gateways (<code>gateways</code>): Interfaces para comunica\u00e7\u00e3o com servi\u00e7os externos, como bancos de dados ou servi\u00e7os de pagamento.</li> <li>Controllers (<code>controllers</code>): Recebem requisi\u00e7\u00f5es da interface de usu\u00e1rio, invocam os use cases apropriados e devolvem respostas.</li> </ul> <p>Essa estrutura permite que mudan\u00e7as em uma camada, como a substitui\u00e7\u00e3o de um banco de dados ou a altera\u00e7\u00e3o da interface de usu\u00e1rio, possam ser realizadas com impacto m\u00ednimo nas outras camadas, especialmente na l\u00f3gica de neg\u00f3cios central.</p> <p>Ao adotar a Clean Architecture, o projeto se beneficia de uma maior flexibilidade, facilitando a implementa\u00e7\u00e3o de novas funcionalidades, a manuten\u00e7\u00e3o do c\u00f3digo e a realiza\u00e7\u00e3o de testes automatizados, garantindo assim a entrega cont\u00ednua de valor para os usu\u00e1rios finais e a sustentabilidade do projeto a longo prazo.</p>"},{"location":"fase_2/entregavel_1/#camadas-da-arquitetura","title":"Camadas da Arquitetura","text":""},{"location":"fase_2/entregavel_1/#entidades","title":"Entidades","text":"<p>Na Clean Architecture, a camada de entidades \u00e9 a espinha dorsal do sistema. Ela encapsula as regras de neg\u00f3cio do dom\u00ednio, que s\u00e3o independentes de qualquer tecnologia externa, como bancos de dados ou interfaces de usu\u00e1rio. As entidades s\u00e3o objetos que representam conceitos do dom\u00ednio do neg\u00f3cio, contendo tanto dados quanto as regras de neg\u00f3cio que governam esses dados.</p> <p>As entidades est\u00e3o localizadas na camada mais interna da Clean Architecture, representando o n\u00facleo do sistema. Elas s\u00e3o cercadas por camadas externas que lidam com aspectos como a interface de usu\u00e1rio, persist\u00eancia de dados e comunica\u00e7\u00e3o com sistemas externos, mas essas camadas dependem das entidades, e n\u00e3o o contr\u00e1rio. Isso garante que as mudan\u00e7as nessas camadas externas tenham um impacto m\u00ednimo sobre as regras de neg\u00f3cio fundamentais do sistema.</p> <p>As entidades devem ser projetadas para serem facilmente test\u00e1veis, permitindo a verifica\u00e7\u00e3o das regras de neg\u00f3cio atrav\u00e9s de testes unit\u00e1rios. Isso \u00e9 crucial para garantir a qualidade e a confiabilidade do sistema.</p> <p>Uma entidade da nossa solu\u00e7\u00e3o \u00e9 definida por:</p> <ul> <li>Atributos: Representam as propriedades da entidade. Por exemplo, um <code>Pedido</code> pode ter atributos como id, cliente, itens do pedido, status, data de cria\u00e7\u00e3o e data de atualiza\u00e7\u00e3o.</li> <li>M\u00e9todos de Neg\u00f3cio: Encapsulam as regras de neg\u00f3cio relevantes para a entidade. Isso pode incluir valida\u00e7\u00f5es, c\u00e1lculos e opera\u00e7\u00f5es que alteram o estado da entidade de maneira controlada.</li> <li>Construtores: Usados para criar inst\u00e2ncias da entidade, garantindo que elas estejam em um estado v\u00e1lido desde o in\u00edcio.</li> <li>Getters/Setters: M\u00e9todos para acessar e modificar os atributos da entidade. Embora o acesso direto aos atributos possa ser permitido em algumas linguagens, o uso de m\u00e9todos permite maior controle sobre como os atributos s\u00e3o acessados e modificados.</li> </ul> <p>Utilizamos tamb\u00e9m os seguintes princ\u00edpios de design:</p> <ul> <li>Encapsulamento: As entidades devem gerenciar seu pr\u00f3prio estado atrav\u00e9s de m\u00e9todos de neg\u00f3cio, protegendo seus atributos contra acessos e modifica\u00e7\u00f5es indevidas.</li> <li>Valida\u00e7\u00e3o: As entidades s\u00e3o respons\u00e1veis por validar seu estado para garantir que estejam sempre em condi\u00e7\u00f5es v\u00e1lidas de acordo com as regras de neg\u00f3cio.</li> <li>Independ\u00eancia: As entidades n\u00e3o devem depender de detalhes de implementa\u00e7\u00e3o de camadas externas, como persist\u00eancia de dados ou apresenta\u00e7\u00e3o, mantendo a pureza das regras de neg\u00f3cio.</li> </ul>"},{"location":"fase_2/entregavel_1/#casos-de-uso","title":"Casos de Uso","text":"<p>Na Clean Architecture, a camada de Use Cases (Casos de Uso) \u00e9 respons\u00e1vel por implementar as regras de neg\u00f3cio espec\u00edficas da aplica\u00e7\u00e3o. Ela atua como intermedi\u00e1ria entre a interface de usu\u00e1rio (ou qualquer outro tipo de interface externa) e o dom\u00ednio do neg\u00f3cio, representado pelas entidades. Os Use Cases orquestram o fluxo de dados para e das entidades, e direcionam esses dados para onde eles precisam ir.</p> <p>Os Use Cases est\u00e3o localizados em uma camada intermedi\u00e1ria na Clean Architecture, entre as entidades (n\u00facleo do dom\u00ednio de neg\u00f3cio) e os adaptadores (interfaces com o mundo externo). Eles s\u00e3o cruciais para garantir que as regras de neg\u00f3cio sejam aplicadas corretamente, independentemente de como os dados s\u00e3o apresentados ao usu\u00e1rio ou de onde eles v\u00eam.</p> <p>A camada de Use Cases \u00e9 essencial para a organiza\u00e7\u00e3o e a clareza da l\u00f3gica de neg\u00f3cio em um sistema seguindo a Clean Architecture. Ao focar nas opera\u00e7\u00f5es que o sistema precisa realizar, sem se prender a detalhes de implementa\u00e7\u00e3o espec\u00edficos de tecnologia, os Use Cases permitem uma maior flexibilidade, manutenibilidade e escalabilidade do software.</p> <p>Um caso de uso em nossa solu\u00e7\u00e3o \u00e9 definido por:</p> <ul> <li>Entradas: Dados necess\u00e1rios para executar o caso de uso. Por exemplo, os IDs necess\u00e1rios para criar um novo pedido.</li> <li>M\u00e9todos: A\u00e7\u00f5es que o caso de uso pode realizar, como listar pedidos, criar um novo pedido, entre outros. Cada m\u00e9todo implementa uma parte da l\u00f3gica de neg\u00f3cio, manipulando uma ou mais entidades conforme necess\u00e1rio.</li> </ul> <p>Utilizamos tamb\u00e9m os seguintes princ\u00edpios de design:</p> <ul> <li>Foco na L\u00f3gica de Neg\u00f3cio: Use Cases encapsulam a l\u00f3gica de neg\u00f3cio espec\u00edfica da aplica\u00e7\u00e3o, mantendo-a separada das preocupa\u00e7\u00f5es de interface de usu\u00e1rio e persist\u00eancia de dados.</li> <li>Independ\u00eancia: Use Cases s\u00e3o independentes de frameworks e interfaces externas, permitindo que a l\u00f3gica de neg\u00f3cio seja reutilizada em diferentes contextos.</li> <li>Testabilidade: A separa\u00e7\u00e3o clara de responsabilidades e a independ\u00eancia de tecnologias externas facilitam a escrita de testes unit\u00e1rios e de integra\u00e7\u00e3o para os Use Cases.</li> </ul>"},{"location":"fase_2/entregavel_1/#gateways","title":"Gateways","text":"<p>Na Clean Architecture, a camada de Gateways \u00e9 respons\u00e1vel pela comunica\u00e7\u00e3o entre a aplica\u00e7\u00e3o e fontes de dados externas, como bancos de dados, APIs de terceiros, sistemas de arquivos, entre outros. Os Gateways abstraem os detalhes espec\u00edficos de acesso a essas fontes de dados, permitindo que a l\u00f3gica de neg\u00f3cio da aplica\u00e7\u00e3o interaja com elas de maneira agn\u00f3stica em rela\u00e7\u00e3o \u00e0 tecnologia utilizada.</p> <p>Os Gateways est\u00e3o localizados na camada externa da Clean Architecture, servindo como ponte entre a l\u00f3gica de neg\u00f3cio da aplica\u00e7\u00e3o (Use Cases) e as fontes de dados ou servi\u00e7os externos. Eles s\u00e3o parte dos Adapters na terminologia da Clean Architecture, adaptando a interface que a aplica\u00e7\u00e3o espera para a interface que os servi\u00e7os externos fornecem.</p> <p>A camada de Gateways \u00e9 crucial para manter a flexibilidade, escalabilidade e testabilidade da aplica\u00e7\u00e3o. Ao encapsular os detalhes espec\u00edficos de acesso a dados e fornecer uma interface limpa e abstrata para a l\u00f3gica de neg\u00f3cio, os Gateways permitem que a aplica\u00e7\u00e3o evolua de forma sustent\u00e1vel, facilitando a manuten\u00e7\u00e3o e a adi\u00e7\u00e3o de novas funcionalidades.</p> <p>Um Gateway na nossa aplica\u00e7\u00e3o \u00e9 definido por:</p> <ul> <li>Cliente: Uma inst\u00e2ncia do cliente de banco de dados ou servi\u00e7o externo. Por exemplo, em nossa aplica\u00e7\u00e3o, <code>client</code> \u00e9 uma inst\u00e2ncia do cliente PostgreSQL.</li> <li>Reposit\u00f3rios Associados: Refer\u00eancias a outros gateways ou adapters necess\u00e1rios para completar opera\u00e7\u00f5es complexas que envolvem m\u00faltiplas entidades ou fontes de dados. Por exemplo, o reposit\u00f3rio de cliente e o reposit\u00f3rio de produto s\u00e3o usados para buscar informa\u00e7\u00f5es adicionais necess\u00e1rias para construir um objeto <code>Pedido</code> completo.</li> </ul> <p>Utilizamos tamb\u00e9m os seguintes princ\u00edpios de design:</p> <ul> <li>Separa\u00e7\u00e3o de Responsabilidades: Os Gateways separam a l\u00f3gica de acesso a dados da l\u00f3gica de neg\u00f3cio, permitindo mudan\u00e7as em um sem afetar o outro.</li> <li>Abstra\u00e7\u00e3o: Ao abstrair os detalhes de implementa\u00e7\u00e3o do acesso a dados, os Gateways facilitam a substitui\u00e7\u00e3o ou modifica\u00e7\u00e3o das fontes de dados sem impactar a aplica\u00e7\u00e3o.</li> <li>Reusabilidade: Os Gateways podem ser reutilizados em diferentes partes da aplica\u00e7\u00e3o, promovendo a consist\u00eancia e reduzindo a duplica\u00e7\u00e3o de c\u00f3digo.</li> </ul>"},{"location":"fase_2/entregavel_1/#controllers","title":"Controllers","text":"<p>Na Clean Architecture, a camada de Controllers serve como um ponto de entrada para as requisi\u00e7\u00f5es vindas de interfaces externas, como uma interface de usu\u00e1rio web, uma API REST, ou um terminal de linha de comando. Os Controllers interpretam as requisi\u00e7\u00f5es, invocam os Use Cases apropriados e retornam as respostas adequadas. Eles agem como mediadores entre a interface externa e a l\u00f3gica de neg\u00f3cio da aplica\u00e7\u00e3o.</p> <p>Os Controllers est\u00e3o localizados na camada mais externa da Clean Architecture, diretamente em contato com as interfaces de usu\u00e1rio ou outros sistemas externos. Eles traduzem as requisi\u00e7\u00f5es dessas fontes em opera\u00e7\u00f5es nos Use Cases e adaptam as respostas dos Use Cases de volta para o formato esperado pela interface externa.</p> <p>A camada de Controllers \u00e9 essencial para manter a interface de usu\u00e1rio ou API da aplica\u00e7\u00e3o claramente separada da l\u00f3gica de neg\u00f3cio interna. Isso n\u00e3o apenas facilita a manuten\u00e7\u00e3o e a evolu\u00e7\u00e3o da aplica\u00e7\u00e3o, mas tamb\u00e9m permite que a mesma l\u00f3gica de neg\u00f3cio seja exposta atrav\u00e9s de m\u00faltiplas interfaces sem duplica\u00e7\u00e3o de c\u00f3digo.</p> <p>Um Controller em nossa aplica\u00e7\u00e3o \u00e9 definido por:</p> <ul> <li>Use Cases: Refer\u00eancias aos Use Cases que encapsulam a l\u00f3gica de neg\u00f3cio espec\u00edfica que o Controller precisa executar. No exemplo, <code>pedidos_e_pagamentos_use_case</code> e <code>preparacao_e_entrega_use_case</code> s\u00e3o usados para gerenciar pedidos e seus pagamentos.</li> <li>M\u00e9todos de A\u00e7\u00e3o: Cada m\u00e9todo no Controller corresponde a uma a\u00e7\u00e3o que pode ser realizada pela aplica\u00e7\u00e3o, como <code>get_pedidos</code>, <code>novo_pedido</code>, entre outros. Esses m\u00e9todos lidam com a l\u00f3gica de intera\u00e7\u00e3o com os Use Cases e formatam as respostas para a interface externa.</li> </ul> <p>Utilizamos tamb\u00e9m os seguintes princ\u00edpios de design:</p> <ul> <li>Separa\u00e7\u00e3o de Responsabilidades: Os Controllers separam a l\u00f3gica de intera\u00e7\u00e3o com o usu\u00e1rio da l\u00f3gica de neg\u00f3cio, facilitando a manuten\u00e7\u00e3o e a evolu\u00e7\u00e3o de ambos de forma independente.</li> <li>Simplicidade: Os Controllers devem ser simples, delegando a maior parte do trabalho pesado para os Use Cases e outros componentes da aplica\u00e7\u00e3o.</li> <li>Reusabilidade: Embora os Controllers sejam espec\u00edficos para a interface que est\u00e3o servindo, a l\u00f3gica de neg\u00f3cio que eles invocam \u00e9 reutiliz\u00e1vel em diferentes contextos.</li> </ul>"},{"location":"fase_2/entregavel_2/","title":"Entreg\u00e1vel 2","text":""},{"location":"fase_2/entregavel_2/#infraestrutura-kubernetes","title":"Infraestrutura Kubernetes","text":"<p>Como estamos organizando os manifestos?</p> <p>Kustomize \u00e9 uma ferramenta de configura\u00e7\u00e3o de aplica\u00e7\u00f5es Kubernetes que permite a personaliza\u00e7\u00e3o de recursos de configura\u00e7\u00e3o sem a necessidade de templates. Com Kustomize, \u00e9 poss\u00edvel gerenciar as configura\u00e7\u00f5es Kubernetes de forma declarativa, utilizando arquivos YAML para definir os recursos necess\u00e1rios para a aplica\u00e7\u00e3o. O Kustomize permite a sobreposi\u00e7\u00e3o e a composi\u00e7\u00e3o de diferentes configura\u00e7\u00f5es, facilitando a reutiliza\u00e7\u00e3o e a manuten\u00e7\u00e3o das defini\u00e7\u00f5es de infraestrutura. O Kustomize \u00e9 integrado ao <code>kubectl</code>, permitindo o uso do comando <code>kubectl apply -k</code> para aplicar as configura\u00e7\u00f5es definidas com Kustomize diretamente no cluster Kubernetes.</p>"},{"location":"fase_2/entregavel_2/#construcao-dos-manifestos","title":"Constru\u00e7\u00e3o dos Manifestos","text":""},{"location":"fase_2/entregavel_2/#app-deployment","title":"app-deployment","text":"<p>O arquivo define o Deployment da nossa aplica\u00e7\u00e3o Rust. O Deployment \u00e9 respons\u00e1vel por gerenciar a cria\u00e7\u00e3o, a atualiza\u00e7\u00e3o e a escala dos Pods que hospedam os containers da aplica\u00e7\u00e3o. Ele garante que o n\u00famero especificado de r\u00e9plicas do Pod esteja sempre em execu\u00e7\u00e3o, facilitando a atualiza\u00e7\u00e3o e a manuten\u00e7\u00e3o da aplica\u00e7\u00e3o sem interrup\u00e7\u00f5es no servi\u00e7o.</p> <p>A configura\u00e7\u00e3o inclui a defini\u00e7\u00e3o de uma \u00fanica r\u00e9plica do Pod, garantindo a execu\u00e7\u00e3o de uma inst\u00e2ncia da nossa aplica\u00e7\u00e3o. Utilizamos a imagem Docker <code>brunomafra/grupo-25-tech-challenge:latest</code> para os containers, e a aplica\u00e7\u00e3o \u00e9 configurada para expor a porta <code>3000</code>. As vari\u00e1veis de ambiente s\u00e3o injetadas a partir de um ConfigMap, permitindo uma configura\u00e7\u00e3o externa flex\u00edvel. Al\u00e9m disso, especificamos um pedido m\u00ednimo de <code>1m</code> de CPU para o container. Os trechos para <code>livenessProbe</code> e <code>readinessProbe</code> s\u00e3o preparados para monitorar a sa\u00fade do container, essenciais para garantir a disponibilidade e a confiabilidade da aplica\u00e7\u00e3o em produ\u00e7\u00e3o.</p>"},{"location":"fase_2/entregavel_2/#app-hpa","title":"app-hpa","text":"<p>O arquivo define um Horizontal Pod Autoscaler (HPA) para nossa aplica\u00e7\u00e3o Rust, essencial para garantir a escalabilidade e a efici\u00eancia de recursos na nossa infraestrutura Kubernetes. O HPA monitora automaticamente a utiliza\u00e7\u00e3o de recursos, como CPU, dos Pods gerenciados pelo Deployment especificado e ajusta o n\u00famero de r\u00e9plicas com base nas m\u00e9tricas observadas. Isso assegura que a aplica\u00e7\u00e3o possa lidar com varia\u00e7\u00f5es na carga de trabalho, aumentando ou diminuindo o n\u00famero de Pods conforme necess\u00e1rio, sem interven\u00e7\u00e3o manual.</p> <p>A configura\u00e7\u00e3o do HPA est\u00e1 direcionada ao Deployment, com o n\u00famero m\u00ednimo de r\u00e9plicas definido como <code>1</code> e o m\u00e1ximo como <code>10</code>. Isso significa que a aplica\u00e7\u00e3o sempre ter\u00e1 pelo menos um Pod em execu\u00e7\u00e3o, podendo escalar at\u00e9 dez Pods com base na demanda. O crit\u00e9rio de escalabilidade \u00e9 a utiliza\u00e7\u00e3o de CPU, com o HPA configurado para aumentar o n\u00famero de r\u00e9plicas quando a utiliza\u00e7\u00e3o m\u00e9dia de CPU dos Pods exceder <code>30%</code>. Essa abordagem permite um balanceamento eficaz entre o desempenho da aplica\u00e7\u00e3o e o uso de recursos, adaptando-se dinamicamente \u00e0s necessidades de carga de trabalho.</p>"},{"location":"fase_2/entregavel_2/#app-metrics","title":"app-metrics","text":"<p>Este arquivo habilita a coleta e o fornecimento de m\u00e9tricas de recursos (como CPU e mem\u00f3ria) dos Pods e n\u00f3s no nosso cluster Kubernetes. A configura\u00e7\u00e3o estabelece o Metrics Server como um agregador de m\u00e9tricas, que \u00e9 utilizado por recursos como o Horizontal Pod Autoscaler (HPA) para tomar decis\u00f5es de escalabilidade baseadas no uso de recursos.</p> <p>\u00c9 respons\u00e1vel por configurar as permiss\u00f5es necess\u00e1rias atrav\u00e9s de <code>ServiceAccount</code>, <code>ClusterRoles</code> e <code>Bindings</code> para que o Metrics Server possa acessar e coletar m\u00e9tricas de recursos. Ele tamb\u00e9m define um servi\u00e7o no namespace <code>kube-system</code> para expor o Metrics Server internamente no cluster, al\u00e9m de um Deployment que especifica a vers\u00e3o da imagem do Metrics Server, argumentos de inicializa\u00e7\u00e3o para sua configura\u00e7\u00e3o adequada, e probes de <code>liveness</code> e <code>readiness</code> para assegurar a opera\u00e7\u00e3o cont\u00ednua e confi\u00e1vel do servi\u00e7o. Por fim, um <code>APIService</code> \u00e9 registrado, permitindo o acesso \u00e0s m\u00e9tricas coletadas atrav\u00e9s da API do Kubernetes, facilitando a automa\u00e7\u00e3o e o monitoramento baseados em m\u00e9tricas no cluster, o que \u00e9 crucial para a escalabilidade e a efici\u00eancia da gest\u00e3o de recursos.</p>"},{"location":"fase_2/entregavel_2/#app-svc","title":"app-svc","text":"<p>Este arquivo define um Service no Kubernetes para nossa aplica\u00e7\u00e3o Rust. O principal objetivo desse Service \u00e9 fornecer um ponto de acesso est\u00e1vel para os Pods que executam nossa aplica\u00e7\u00e3o, permitindo a comunica\u00e7\u00e3o com a aplica\u00e7\u00e3o tanto internamente, dentro do cluster, quanto externamente. O Service abstrai a l\u00f3gica de roteamento e permite que a aplica\u00e7\u00e3o seja acessada sem a necessidade de saber a localiza\u00e7\u00e3o exata dos Pods ou suas inst\u00e2ncias.</p> <p>O Service \u00e9 configurado como um <code>NodePort</code>, o que significa que ele estar\u00e1 acess\u00edvel em uma porta espec\u00edfica (<code>31200</code>) em todos os n\u00f3s do cluster. Isso facilita o acesso \u00e0 aplica\u00e7\u00e3o de fora do cluster Kubernetes. O Service direciona o tr\u00e1fego para os Pods que correspondem ao seletor, garantindo que as requisi\u00e7\u00f5es sejam encaminhadas para a aplica\u00e7\u00e3o correta. As portas s\u00e3o configuradas para que o tr\u00e1fego TCP na porta <code>3000</code> do n\u00f3 seja direcionado para a porta <code>3000</code> do container, que \u00e9 a porta em que nossa aplica\u00e7\u00e3o Rust est\u00e1 ouvindo. Essa configura\u00e7\u00e3o destaca a import\u00e2ncia de definir claramente os pontos de comunica\u00e7\u00e3o e acesso para a aplica\u00e7\u00e3o dentro da infraestrutura Kubernetes, promovendo a disponibilidade e a escalabilidade da aplica\u00e7\u00e3o.</p>"},{"location":"fase_2/entregavel_2/#configmap","title":"configmap","text":"<p>Este arquivo define um ConfigMap chamado na nossa infraestrutura Kubernetes. O ConfigMap \u00e9 utilizado para armazenar configura\u00e7\u00f5es em formato de chave-valor, que podem ser consumidas por Pods na aplica\u00e7\u00e3o. O principal objetivo desse ConfigMap \u00e9 fornecer uma maneira flex\u00edvel e centralizada de gerenciar configura\u00e7\u00f5es externas para a nossa aplica\u00e7\u00e3o, como informa\u00e7\u00f5es de conex\u00e3o ao banco de dados e URLs de servi\u00e7os externos, sem a necessidade de hardcoding essas informa\u00e7\u00f5es nos arquivos da aplica\u00e7\u00e3o.</p>"},{"location":"fase_2/entregavel_2/#db-postgres","title":"db-postgres","text":"<p>O arquivo define um Pod no Kubernetes para hospedar o banco de dados PostgreSQL. O objetivo principal desse Pod \u00e9 fornecer um servi\u00e7o de banco de dados persistente e confi\u00e1vel para nossa aplica\u00e7\u00e3o, permitindo o armazenamento e a recupera\u00e7\u00e3o de dados de forma eficiente. Utilizando um Pod para o banco de dados, podemos aproveitar os recursos de orquestra\u00e7\u00e3o do Kubernetes para gerenciar a disponibilidade e a escalabilidade do servi\u00e7o de banco de dados.</p> <p>O Pod \u00e9 configurado para executar um \u00fanico container, utilizando a imagem <code>m</code>, que \u00e9 uma vers\u00e3o leve do PostgreSQL. O container exp\u00f5e a porta <code>5432</code>, que \u00e9 a porta padr\u00e3o para conex\u00f5es ao PostgreSQL, facilitando a comunica\u00e7\u00e3o com a aplica\u00e7\u00e3o. As configura\u00e7\u00f5es do banco de dados, como nome do banco, usu\u00e1rio e senha, s\u00e3o injetadas no container atrav\u00e9s de vari\u00e1veis de ambiente definidas em um ConfigMap.</p>"},{"location":"fase_2/entregavel_2/#db-svc","title":"db-svc","text":"<p>Esse arquivo cria um Service no Kubernetes que tem como objetivo principal fornecer um ponto de acesso est\u00e1vel e confi\u00e1vel ao banco de dados PostgreSQL. O Service facilita a comunica\u00e7\u00e3o entre a aplica\u00e7\u00e3o e o banco de dados, permitindo que os componentes da aplica\u00e7\u00e3o se conectem ao banco de dados usando um nome de servi\u00e7o fixo, independentemente das mudan\u00e7as nos Pods que realmente executam o banco de dados.</p> <p>O Service \u00e9 configurado para expor a porta <code>5432</code>, que \u00e9 a porta padr\u00e3o usada pelo PostgreSQL para aceitar conex\u00f5es. Ele utiliza um seletor para direcionar o tr\u00e1fego para o Pod que executa o banco de dados. Essa configura\u00e7\u00e3o garante que qualquer componente da aplica\u00e7\u00e3o que precise se conectar ao banco de dados PostgreSQL possa faz\u00ea-lo atrav\u00e9s do nome do servi\u00e7o, proporcionando uma maneira consistente e desacoplada de acessar o banco de dados dentro do cluster Kubernetes.</p>"},{"location":"fase_2/entregavel_2/#mock-pagamentos-pod","title":"mock-pagamentos-pod","text":"<p>Este arquivo define um Pod cujo objetivo \u00e9 simular um servi\u00e7o de pagamentos para fins de desenvolvimento e teste da nossa aplica\u00e7\u00e3o. Ao utilizar um mock para o servi\u00e7o de pagamentos, podemos validar a integra\u00e7\u00e3o e o fluxo de pagamentos da aplica\u00e7\u00e3o sem a necessidade de interagir com um servi\u00e7o de pagamentos real, facilitando o desenvolvimento e os testes em ambientes isolados ou de desenvolvimento.</p> <p>O Pod \u00e9 configurado para executar um \u00fanico container, que utiliza a imagem <code>brunomafra/mock-pagamentos:latest</code>. Esta imagem cont\u00e9m a aplica\u00e7\u00e3o mock de pagamentos, projetada para simular as respostas e comportamentos de um servi\u00e7o de pagamentos real. O container \u00e9 configurado para expor a porta <code>9000</code>, que \u00e9 a porta na qual o servi\u00e7o mock de pagamentos aceita requisi\u00e7\u00f5es. Atrav\u00e9s dessa configura\u00e7\u00e3o, outros componentes da nossa aplica\u00e7\u00e3o podem se conectar ao servi\u00e7o mock de pagamentos usando o nome do Pod e a porta <code>9000</code>, permitindo testar o fluxo de pagamentos sem afetar sistemas de pagamento reais ou incorrer em custos.</p>"},{"location":"fase_2/entregavel_2/#mock-pagamentos-svc","title":"mock-pagamentos-svc","text":"<p>Este arquivo cria um Service cujo principal objetivo \u00e9 fornecer um ponto de acesso est\u00e1vel ao Pod que simula um servi\u00e7o de pagamentos. Esse Service facilita a comunica\u00e7\u00e3o entre a nossa aplica\u00e7\u00e3o e o servi\u00e7o mock de pagamentos, permitindo que a aplica\u00e7\u00e3o interaja com o mock como se fosse um servi\u00e7o de pagamentos real, mas dentro do ambiente controlado do nosso cluster Kubernetes.</p> <p>O Service \u00e9 configurado para expor a porta <code>9000</code>, que \u00e9 a porta na qual o servi\u00e7o mock de pagamentos est\u00e1 ouvindo por requisi\u00e7\u00f5es. Ele utiliza um seletor para direcionar o tr\u00e1fego para o Pod correto que executa o mock de pagamentos. Essa configura\u00e7\u00e3o garante que qualquer componente da nossa aplica\u00e7\u00e3o que precise simular uma intera\u00e7\u00e3o com um servi\u00e7o de pagamentos possa faz\u00ea-lo de maneira consistente e confi\u00e1vel, utilizando o nome do servi\u00e7o para se conectar ao mock.</p>"},{"location":"fase_2/entregavel_3/","title":"Entreg\u00e1vel 3","text":""},{"location":"fase_2/entregavel_3/#arquitetura-kubernetes","title":"Arquitetura Kubernetes","text":"<p>O diagrama abaixo ilustra a arquitetura projetada para nossa aplica\u00e7\u00e3o executar utilizando um cluster Kubernetes:</p> <p> </p> Diagrama da Arquitetura Kubernetes <p>Podemos sintetizar os seguintes requisitos de neg\u00f3cio contemplados pela arquitetura:</p> <p>1. Disponibilidade e Escalabilidade: A utiliza\u00e7\u00e3o de Deployments e Services, juntamente com o Horizontal Pod Autoscaler (HPA), garante que a aplica\u00e7\u00e3o esteja sempre dispon\u00edvel para os usu\u00e1rios. O HPA permite que a aplica\u00e7\u00e3o escale automaticamente com base na demanda, atendendo a picos de tr\u00e1fego sem interven\u00e7\u00e3o manual.</p> <p>2. Gerenciamento de Configura\u00e7\u00e3o: O uso de ConfigMaps para armazenar configura\u00e7\u00f5es externas, como informa\u00e7\u00f5es de conex\u00e3o ao banco de dados e URLs de servi\u00e7os, permite uma gest\u00e3o centralizada e flex\u00edvel das configura\u00e7\u00f5es. Isso facilita ajustes e atualiza\u00e7\u00f5es sem a necessidade de reconstruir ou reiniciar os containers.</p> <p>3. Isolamento e Seguran\u00e7a: A separa\u00e7\u00e3o do banco de dados e do servi\u00e7o mock de pagamentos em Pods distintos, juntamente com a comunica\u00e7\u00e3o atrav\u00e9s de Services, promove o isolamento entre os componentes da aplica\u00e7\u00e3o. Isso melhora a seguran\u00e7a, limitando o acesso apenas aos recursos necess\u00e1rios para cada componente.</p> <p>4. Integra\u00e7\u00e3o e Testes: A implementa\u00e7\u00e3o de um servi\u00e7o mock de pagamentos permite a simula\u00e7\u00e3o de intera\u00e7\u00f5es com sistemas de pagamento externos, facilitando o desenvolvimento e os testes da integra\u00e7\u00e3o de pagamentos na aplica\u00e7\u00e3o. Isso garante que a aplica\u00e7\u00e3o possa ser testada de forma abrangente em um ambiente controlado antes de ser conectada a servi\u00e7os de pagamento reais.</p> <p>5. Monitoramento e Sa\u00fade da Aplica\u00e7\u00e3o: A inclus\u00e3o de liveness e readiness probes nos manifestos tem como objetivo o monitoramento e preocupa\u00e7\u00e3o com a sa\u00fade da aplica\u00e7\u00e3o. Essas probes ajudam a garantir que o Kubernetes possa gerenciar automaticamente a sa\u00fade dos Pods, reiniciando-os se eles n\u00e3o estiverem respondendo adequadamente.</p> <p>6. Efici\u00eancia de Recursos: A especifica\u00e7\u00e3o de recursos m\u00ednimos necess\u00e1rios para os containers, como CPU, no manifesto do Deployment, assegura que a aplica\u00e7\u00e3o utilize os recursos do cluster de forma eficiente, evitando o uso excessivo e permitindo uma melhor distribui\u00e7\u00e3o dos recursos dispon\u00edveis no cluster.</p> <p>Esses requisitos refletem uma arquitetura projetada para ser resiliente, segura, e f\u00e1cil de gerenciar e escalar, atendendo \u00e0s necessidades de uma aplica\u00e7\u00e3o moderna em um ambiente de cloud como o Kubernetes.</p>"},{"location":"fase_2/entregavel_3/#tutorial-para-execucao-da-aplicacao-com-kubernetes","title":"Tutorial para Execu\u00e7\u00e3o da Aplica\u00e7\u00e3o com Kubernetes","text":"<p>1. Aplicar o ConfigMap</p> <p>O ConfigMap cont\u00e9m configura\u00e7\u00f5es essenciais para a aplica\u00e7\u00e3o e o banco de dados.</p> <pre><code>kubectl apply -f configmap.yaml\n</code></pre> <p>2. Inicializar o Servi\u00e7o do Banco de Dados</p> <p>Cria o servi\u00e7o que permite a comunica\u00e7\u00e3o com o banco de dados PostgreSQL.</p> <pre><code>kubectl apply -f db-svc.yaml\n</code></pre> <p>3. Inicializar o Pod do Banco de Dados</p> <p>Cria o Pod que executa o container do PostgreSQL.</p> <pre><code>kubectl apply -f db-postgres.yaml\n</code></pre> <p>4. Verificar as Migrations do Banco de Dados</p> <p>\u00datil para assegurar que o banco de dados foi inicializado corretamente.</p> <pre><code>kubectl logs db-pod\n</code></pre> <p>5. Inicializar o Metrics Server</p> <p>Necess\u00e1rio para o funcionamento do Horizontal Pod Autoscaler (HPA).</p> <pre><code>kubectl apply -f app-metrics.yaml\n</code></pre> <p>6. Inicializar o Servi\u00e7o da Aplica\u00e7\u00e3o</p> <p>Cria o servi\u00e7o que exp\u00f5e a aplica\u00e7\u00e3o.</p> <pre><code>kubectl apply -f app-svc.yaml\n</code></pre> <p>7. Aplicar o Horizontal Pod Autoscaler</p> <p>Configura o HPA para escalabilidade autom\u00e1tica da aplica\u00e7\u00e3o.</p> <pre><code>kubectl apply -f app-hpa.yaml\n</code></pre> <p>8. Inicializar o Deployment da Aplica\u00e7\u00e3o</p> <p>Cria o Deployment que gerencia os Pods da aplica\u00e7\u00e3o.</p> <pre><code>kubectl apply -f app-deployment.yaml\n</code></pre> <p>9. Verificar se a Aplica\u00e7\u00e3o Iniciou Corretamente</p> <p>Lista os Pods para encontrar o nome do Pod da aplica\u00e7\u00e3o e verificar os logs.</p> <pre><code>kubectl get pods\n# Substitua `&lt;nome_pod&gt;` pelo nome do Pod da aplica\u00e7\u00e3o obtido no passo anterior.\nkubectl logs &lt;nome_pod&gt;\n</code></pre> <p>10. Inicializar o Servi\u00e7o Mock de Pagamentos</p> <p>Cria o servi\u00e7o que exp\u00f5e o mock de pagamentos.</p> <pre><code>kubectl apply -f mock-pagamento-svc.yaml\n</code></pre> <p>11. Inicializar o Pod do Mock de Pagamentos</p> <p>Cria o Pod que executa o mock de pagamentos.</p> <pre><code>kubectl apply -f mock-pagamento-pod.yaml\n</code></pre> <p>12. Verificar se o Mock de Pagamentos Subiu Corretamente</p> <pre><code>kubectl logs mock-pagamentos-pod\n</code></pre> <p>13. Desligar a Infraestrutura</p> <p>Quando terminar, remova todos os recursos criados. Este comando remove todos os recursos dos tipos especificados no namespace atual</p> <pre><code>kubectl delete --all pods\nkubectl delete --all deployments\nkubectl delete --all services\nkubectl delete --all hpa\nkubectl delete --all configmaps\n</code></pre>"},{"location":"fase_2/entregavel_3/#tutorial-para-interacao-com-as-apis","title":"Tutorial para Intera\u00e7\u00e3o com as APIs","text":"<p>Esta se\u00e7\u00e3o fornece uma vis\u00e3o geral dos endpoints dispon\u00edveis para o servi\u00e7o de autoatendimento em constru\u00e7\u00e3o. Para testar os endpoints interativamente, utilize nossa Swagger UI disponibilizada ao fazer o build da aplica\u00e7\u00e3o.</p> <p>Utilizando a collection no Postman</p> <p>Disponibilizamos aqui uma collection no Postman para facilitar as intera\u00e7\u00f5es com os endpoints da aplica\u00e7\u00e3o. Est\u00e3o listados diversos cen\u00e1rios de uso e para utiliz\u00e1-los basta importar a collection alterar os par\u00e2metros das requisi\u00e7\u00f5es diretamente no Postman.</p>"},{"location":"fase_2/entregavel_3/#autenticacao","title":"Autentica\u00e7\u00e3o","text":"<p>A primeira etapa \u00e9 a obten\u00e7\u00e3o de um bearer token de acesso atrav\u00e9s da realiza\u00e7\u00e3o do login na aplica\u00e7\u00e3o. Para isso, basta utilizar o endpoint abaixo passando os devidos par\u00e2metros no corpo da requisi\u00e7\u00e3o:</p> /auth/login <p>Autentica o usu\u00e1rio e retorna um token de acesso.</p> Par\u00e2metro Tipo Descri\u00e7\u00e3o cpf <code>string</code> CPF do usu\u00e1rio. senha <code>string</code> Senha do usu\u00e1rio. <p>Disponibilizamos um usu\u00e1rio administrativo padr\u00e3o pr\u00e9-cadastrado que poder\u00e1 utilizar para autentica\u00e7\u00e3o na aplica\u00e7\u00e3o. Para isso, basta utilizar os seguintes par\u00e2metros:</p> <pre><code>{\n    \"cpf\": \"000.000.000-00\",\n    \"senha\": \"melhor_projeto\"\n}\n</code></pre>"},{"location":"fase_2/entregavel_3/#usuarios","title":"Usu\u00e1rios","text":"<p>Esta se\u00e7\u00e3o detalha os endpoints dispon\u00edveis para gerenciamento de usu\u00e1rios na aplica\u00e7\u00e3o. Esses endpoints permitem criar, recuperar, atualizar e deletar informa\u00e7\u00f5es de usu\u00e1rios.</p> /usuarios/ <p>Recupera uma lista de todos os usu\u00e1rios cadastrados na aplica\u00e7\u00e3o.</p> /usuarios/ <p>Cria um novo usu\u00e1rio com as informa\u00e7\u00f5es fornecidas no corpo da requisi\u00e7\u00e3o.</p> Par\u00e2metro Tipo Descri\u00e7\u00e3o nome <code>string</code> Nome do usu\u00e1rio. email <code>string</code> Email do usu\u00e1rio. senha <code>string</code> Senha do usu\u00e1rio. cpf <code>string</code> CPF do usu\u00e1rio. tipo <code>string</code> Tipo do usu\u00e1rio (<code>Admin</code> ou <code>Cozinha</code>). status <code>string</code> Status do usu\u00e1rio (<code>Ativo</code> ou <code>Inativo</code>). <p>\u00c9 necess\u00e1rio informar um CPF v\u00e1lido no formato <code>123.456.789-00</code>;</p> /usuarios/{id} <p>Recupera os detalhes de um usu\u00e1rio espec\u00edfico pelo seu ID.</p> Par\u00e2metro Tipo Descri\u00e7\u00e3o id <code>integer</code> ID do usu\u00e1rio. /usuarios/{id} <p>Atualiza as informa\u00e7\u00f5es de um usu\u00e1rio espec\u00edfico pelo seu ID com os dados fornecidos no corpo da requisi\u00e7\u00e3o.</p> Par\u00e2metro Tipo Descri\u00e7\u00e3o id <code>integer</code> ID do usu\u00e1rio. /usuarios/{cpf} <p>Remove um usu\u00e1rio espec\u00edfico pelo seu CPF da aplica\u00e7\u00e3o.</p> Par\u00e2metro Tipo Descri\u00e7\u00e3o cpf <code>string</code> CPF do usu\u00e1rio."},{"location":"fase_2/entregavel_3/#clientes","title":"Clientes","text":"<p>Esta se\u00e7\u00e3o detalha os endpoints dispon\u00edveis para gerenciamento de clientes na aplica\u00e7\u00e3o. Esses endpoints permitem criar, recuperar informa\u00e7\u00f5es de clientes.</p> /clientes/ <p>Recupera uma lista de todos os clientes cadastrados na aplica\u00e7\u00e3o.</p> /clientes/ <p>Cadastra um novo cliente com as informa\u00e7\u00f5es fornecidas no corpo da requisi\u00e7\u00e3o.</p> Par\u00e2metro Tipo Descri\u00e7\u00e3o nome <code>string</code> Nome do cliente. email <code>string</code> Email do cliente. cpf <code>string</code> CPF do cliente. <p>\u00c9 necess\u00e1rio informar um CPF v\u00e1lido no formato <code>123.456.789-00</code>;</p> /clientes/{cpf} <p>Recupera os detalhes de um cliente espec\u00edfico pelo seu CPF.</p> Par\u00e2metro Tipo Descri\u00e7\u00e3o cpf <code>string</code> CPF do cliente."},{"location":"fase_2/entregavel_3/#produtos","title":"Produtos","text":"<p>Esta se\u00e7\u00e3o detalha os endpoints dispon\u00edveis para gerenciamento de produtos na aplica\u00e7\u00e3o. Esses endpoints permitem criar, recuperar, atualizar e deletar informa\u00e7\u00f5es de produtos.</p> /produtos/ <p>Recupera uma lista de todos os produtos cadastrados na aplica\u00e7\u00e3o.</p> /produtos/ <p>Cadastra um novo produto com as informa\u00e7\u00f5es fornecidas no corpo da requisi\u00e7\u00e3o.</p> Par\u00e2metro Tipo Descri\u00e7\u00e3o nome <code>string</code> Nome do produto. foto <code>string</code> URL da foto do produto. descricao <code>string</code> Descri\u00e7\u00e3o do produto. categoria <code>string</code> Categoria do produto (<code>Lanche</code>, <code>Bebida</code>, <code>Acompanhamento</code>, <code>Sobremesa</code>). preco <code>number</code> Pre\u00e7o do produto. ingredientes <code>string[]</code> Lista de ingredientes do produto. /produtos/{id} <p>Recupera os detalhes de um produto espec\u00edfico pelo seu ID.</p> Par\u00e2metro Tipo Descri\u00e7\u00e3o id <code>integer</code> ID do produto. /produtos/{id} <p>Atualiza as informa\u00e7\u00f5es de um produto espec\u00edfico pelo seu ID com os dados fornecidos no corpo da requisi\u00e7\u00e3o.</p> Par\u00e2metro Tipo Descri\u00e7\u00e3o id <code>integer</code> ID do produto. /produtos/{id} <p>Remove um produto espec\u00edfico pelo seu ID da aplica\u00e7\u00e3o.</p> Par\u00e2metro Tipo Descri\u00e7\u00e3o id <code>integer</code> ID do produto."},{"location":"fase_2/entregavel_3/#pedidos","title":"Pedidos","text":"<p>Esta se\u00e7\u00e3o detalha os endpoints dispon\u00edveis para gerenciamento de pedidos na aplica\u00e7\u00e3o. Esses endpoints permitem criar, recuperar, atualizar o status de pedidos, associar clientes e produtos a pedidos, e registrar pagamentos.</p> /pedidos/ <p>Recupera uma lista de todos os pedidos cadastrados na aplica\u00e7\u00e3o.</p> /pedidos/ <p>Cria um novo pedido com as informa\u00e7\u00f5es fornecidas no corpo da requisi\u00e7\u00e3o.</p> /pedidos/novos <p>Recupera uma lista de pedidos recentemente criados que ainda n\u00e3o foram processados.</p> /pedidos/{id}/status/{status} <p>Atualiza o status de um pedido espec\u00edfico.</p> Par\u00e2metro Tipo Descri\u00e7\u00e3o id <code>integer</code> ID do pedido. status <code>string</code> Novo status do pedido. /pedidos/{id}/cliente/{cliente_id} <p>Associa um cliente a um pedido espec\u00edfico.</p> Par\u00e2metro Tipo Descri\u00e7\u00e3o id <code>integer</code> ID do pedido. cliente_id <code>integer</code> ID do cliente a ser associado ao pedido. /pedidos/{id}/produto/{categoria}/{produto_id} <p>Adiciona um produto a um pedido espec\u00edfico, categorizando o produto adicionado.</p> Par\u00e2metro Tipo Descri\u00e7\u00e3o id <code>integer</code> ID do pedido. categoria <code>string</code> Categoria do produto a ser adicionado. produto_id <code>integer</code> ID do produto a ser adicionado ao pedido. /pedidos/{id}/pagamento <p>Registra o pagamento de um pedido espec\u00edfico.</p> Par\u00e2metro Tipo Descri\u00e7\u00e3o id <code>integer</code> ID do pedido."},{"location":"fase_3/entregavel_1/","title":"Entreg\u00e1vel 1","text":""},{"location":"fase_3/entregavel_1/#detalhes-do-banco-de-dados","title":"Detalhes do Banco de Dados","text":""},{"location":"fase_3/entregavel_1/#escolha-do-postgresql","title":"Escolha do PostgreSQL","text":"<p>Optamos pelo PostgreSQL como a solu\u00e7\u00e3o de banco de dados para o sistema de autoatendimento ap\u00f3s uma cuidadosa avalia\u00e7\u00e3o de diferentes formatos de bancos de dados. A decis\u00e3o foi baseada na robustez, flexibilidade e no conjunto de recursos avan\u00e7ados que o PostgreSQL oferece, os quais se alinham perfeitamente com as necessidades complexas e em evolu\u00e7\u00e3o do nosso projeto. </p> <p>Em compara\u00e7\u00e3o com outras op\u00e7\u00f5es, o PostgreSQL se destacou por sua capacidade de lidar com dados complexos, extensibilidade, confiabilidade, suporte a concorr\u00eancia, seguran\u00e7a avan\u00e7ada, recursos de pesquisa sofisticados, uma comunidade ativa e um modelo de custo eficiente. A seguir, detalhamos as raz\u00f5es que justificam essa escolha:</p> <ul> <li>Compatibilidade com Dados Complexos: O PostgreSQL suporta uma ampla gama de tipos de dados, incluindo tipos primitivos, como num\u00e9rico, string e booleano, bem como tipos de dados mais complexos, como arrays, JSON/B, e tipos definidos pelo usu\u00e1rio. Isso \u00e9 essencial para armazenar detalhes complexos de pedidos e prefer\u00eancias de clientes.</li> <li>Extensibilidade: O PostgreSQL \u00e9 altamente extens\u00edvel, permitindo definir fun\u00e7\u00f5es, operadores e at\u00e9 tipos de dados personalizados. Isso facilita a adapta\u00e7\u00e3o e expans\u00e3o do sistema conforme as necessidades do neg\u00f3cio evoluem.</li> <li>Confiabilidade e Integridade dos Dados: Conhecido por sua alta confiabilidade, o PostgreSQL suporta transa\u00e7\u00f5es ACID, garantindo a integridade dos dados mesmo em caso de falhas do sistema.</li> <li>Suporte a Concorr\u00eancia: Gra\u00e7as ao seu modelo de concorr\u00eancia baseado em MVCC, o PostgreSQL pode processar muitas transa\u00e7\u00f5es simult\u00e2neas sem bloqueios significativos, essencial para um sistema de autoatendimento que lida com m\u00faltiplos pedidos ao mesmo tempo.</li> <li>Seguran\u00e7a: Oferece um robusto sistema de controle de acesso baseado em fun\u00e7\u00f5es e suporta autentica\u00e7\u00e3o forte e SSL, protegendo os dados contra acessos n\u00e3o autorizados.</li> <li>Recursos de Pesquisa Avan\u00e7ada: Com \u00edndices GIN e GiST, o PostgreSQL executa eficientemente consultas complexas, incluindo buscas em textos completos e opera\u00e7\u00f5es geoespaciais, \u00fatil para an\u00e1lises avan\u00e7adas e melhorias na interface de usu\u00e1rio.</li> <li>Comunidade e Suporte: Possui uma comunidade ativa e um vasto ecossistema de ferramentas e extens\u00f5es, facilitando o suporte e acesso a recursos para desenvolvimento e manuten\u00e7\u00e3o.</li> <li>Custo: Sendo de c\u00f3digo aberto, o PostgreSQL \u00e9 gratuito, ajudando a reduzir os custos iniciais de desenvolvimento e implementa\u00e7\u00e3o.</li> </ul>"},{"location":"fase_3/entregavel_1/#modelagem","title":"Modelagem","text":"Diagrama de Entidade e Relacionamento"},{"location":"fase_3/entregavel_1/#entidades","title":"Entidades","text":"<p><code>usuario</code></p> <ul> <li>Chave Prim\u00e1ria: id</li> <li>Atributos: nome, email, cpf, senha, tipo, status, data_criacao, data_atualizacao</li> </ul> <p><code>produto</code></p> <ul> <li>Chave Prim\u00e1ria: id</li> <li>Atributos: nome, foto, descricao, categoria, preco, ingredientes, data_criacao, data_atualizacao</li> </ul> <p><code>cliente</code></p> <ul> <li>Chave Prim\u00e1ria: id</li> <li>Atributos: nome, email, cpf, data_criacao, data_atualizacao</li> </ul> <p><code>pedido</code></p> <ul> <li>Chave Prim\u00e1ria: id</li> <li>Atributos: cliente_id, lanche_id, acompanhamento_id, bebida_id, pagamento, status, data_criacao, data_atualizacao</li> <li>Rela\u00e7\u00f5es:<ul> <li>cliente_id \u00e9 uma chave estrangeira que referencia <code>cliente</code>(id)</li> <li>lanche_id, acompanhamento_id, bebida_id s\u00e3o chaves estrangeiras que referenciam <code>produto</code>(id)</li> </ul> </li> </ul> <p><code>pagamento</code></p> <ul> <li>Chave Prim\u00e1ria: id</li> <li>Atributos: id_pedido, estado, valor, metodo, referencia, data_criacao</li> <li>Rela\u00e7\u00f5es:<ul> <li>id_pedido \u00e9 uma chave estrangeira que referencia <code>pedido</code>(id)</li> </ul> </li> </ul>"},{"location":"fase_3/entregavel_1/#relacionamentos","title":"Relacionamentos","text":"<ul> <li><code>pedido</code> para <code>cliente</code>: Um relacionamento de muitos para um (N:1), onde cada pedido est\u00e1 associado a um \u00fanico cliente, mas um cliente pode ter v\u00e1rios pedidos.</li> <li><code>pedido</code> para <code>produto</code>: Um relacionamento de muitos para muitos (N:N), representado atrav\u00e9s das chaves estrangeiras lanche_id, acompanhamento_id, bebida_id em pedido, indicando que um pedido pode incluir v\u00e1rios produtos e um produto pode estar em v\u00e1rios pedidos.</li> <li><code>pagamento</code> para <code>pedido</code>: Um relacionamento de um para um (1:1) ou um para muitos (1:N), dependendo de como os pagamentos s\u00e3o gerenciados. Cada pagamento est\u00e1 associado a um \u00fanico pedido, mas um pedido pode ter v\u00e1rios pagamentos se forem permitidos pagamentos parciais.</li> </ul>"},{"location":"fase_3/entregavel_1/#tabelas","title":"Tabelas","text":""},{"location":"fase_3/entregavel_1/#usuario","title":"<code>usuario</code>","text":"<p>Projetada para armazenar informa\u00e7\u00f5es essenciais sobre os usu\u00e1rios que interagem com o sistema, sejam eles funcion\u00e1rios da cozinha, administradores ou qualquer outro tipo de usu\u00e1rio que necessite de acesso ao sistema administrativo. Esta tabela \u00e9 fundamental para o controle de acesso e a gest\u00e3o de permiss\u00f5es dentro do sistema.</p> Nome da Coluna Tipo de Dado Descri\u00e7\u00e3o id <code>SERIAL</code> Identificador \u00fanico do usu\u00e1rio nome <code>TEXT</code> Nome do usu\u00e1rio email <code>TEXT</code> E-mail do usu\u00e1rio cpf <code>TEXT</code> CPF do usu\u00e1rio senha <code>TEXT</code> Senha do usu\u00e1rio tipo <code>TIPO_USUARIO_ENUM</code> Tipo do usu\u00e1rio (Admin ou Cozinha) status <code>STATUS_USUARIO_ENUM</code> Status do usu\u00e1rio (Ativo ou Inativo) data_criacao <code>TIMESTAMP</code> Data de cria\u00e7\u00e3o do registro data_atualizacao <code>TIMESTAMP</code> Data de atualiza\u00e7\u00e3o do registro"},{"location":"fase_3/entregavel_1/#produto","title":"<code>produto</code>","text":"<p>Projetada para armazenar informa\u00e7\u00f5es sobre os produtos oferecidos pela lanchonete, como lanches, bebidas, acompanhamentos e sobremesas. Esta tabela \u00e9 essencial para o cat\u00e1logo de produtos do sistema de autoatendimento, permitindo aos clientes visualizar detalhes como nome, descri\u00e7\u00e3o, pre\u00e7o e ingredientes de cada produto.</p> Nome da Coluna Tipo de Dado Descri\u00e7\u00e3o id <code>SERIAL</code> Identificador \u00fanico do produto nome <code>TEXT</code> Nome do produto foto <code>TEXT</code> URL da foto do produto descricao <code>TEXT</code> Descri\u00e7\u00e3o do produto categoria <code>CATEGORIA_ENUM</code> Categoria do produto preco <code>FLOAT</code> Pre\u00e7o do produto ingredientes <code>TEXT []</code> Lista de ingredientes do produto data_criacao <code>TIMESTAMP</code> Data de cria\u00e7\u00e3o do registro data_atualizacao <code>TIMESTAMP</code> Data de atualiza\u00e7\u00e3o do registro"},{"location":"fase_3/entregavel_1/#cliente","title":"<code>cliente</code>","text":"<p>Projetada para armazenar informa\u00e7\u00f5es sobre os clientes que utilizam o sistema de autoatendimento. Armazenar os dados dos clientes permite ao sistema oferecer uma experi\u00eancia personalizada e facilitar o processo de pedidos.</p> Nome da Coluna Tipo de Dado Descri\u00e7\u00e3o id <code>SERIAL</code> Identificador \u00fanico do cliente nome <code>TEXT</code> Nome do cliente email <code>TEXT</code> E-mail do cliente cpf <code>TEXT</code> CPF do cliente data_criacao <code>TIMESTAMP</code> Data de cria\u00e7\u00e3o do registro data_atualizacao <code>TIMESTAMP</code> Data de atualiza\u00e7\u00e3o do registro"},{"location":"fase_3/entregavel_1/#pedido","title":"<code>pedido</code>","text":"<p>Essencial para o registro e acompanhamento dos pedidos realizados no sistema de autoatendimento. Vincula pedidos a clientes e detalha os itens selecionados, al\u00e9m de armazenar o status do pedido.</p> Nome da Coluna Tipo de Dado Descri\u00e7\u00e3o id <code>SERIAL</code> Identificador \u00fanico do pedido cliente_id <code>INT</code> ID do cliente que fez o pedido lanche_id <code>INT</code> ID do lanche no pedido acompanhamento_id <code>INT</code> ID do acompanhamento no pedido bebida_id <code>INT</code> ID da bebida no pedido pagamento <code>TEXT</code> Informa\u00e7\u00e3o de pagamento status <code>STATUS_PEDIDO_ENUM</code> Status do pedido data_criacao <code>TIMESTAMP</code> Data de cria\u00e7\u00e3o do registro data_atualizacao <code>TIMESTAMP</code> Data de atualiza\u00e7\u00e3o do registro"},{"location":"fase_3/entregavel_1/#pagamento","title":"<code>pagamento</code>","text":"<p>Projetada para registrar detalhes das transa\u00e7\u00f5es financeiras associadas a cada pedido, crucial para o gerenciamento financeiro do sistema de autoatendimento.</p> Nome da Coluna Tipo de Dado Descri\u00e7\u00e3o id <code>SERIAL</code> Identificador \u00fanico do pagamento id_pedido <code>INT</code> ID do pedido associado estado <code>TEXT</code> Estado do pagamento valor <code>FLOAT</code> Valor do pagamento metodo <code>TEXT</code> M\u00e9todo de pagamento utilizado referencia <code>TEXT</code> Refer\u00eancia da transa\u00e7\u00e3o data_criacao <code>TIMESTAMP</code> Data de cria\u00e7\u00e3o do registro"},{"location":"fase_3/entregavel_1/#aws-rds-para-postgresql","title":"AWS RDS para PostgreSQL","text":"<p>No projeto, optamos pelo Amazon Relational Database Service (RDS) para implementar nossa inst\u00e2ncia do banco de dados PostgreSQL. A escolha do AWS RDS \u00e9 fundamentada em sua capacidade de fornecer uma solu\u00e7\u00e3o de banco de dados relacional escal\u00e1vel, segura e de alta disponibilidade, com gerenciamento simplificado, o que nos permite focar no desenvolvimento da aplica\u00e7\u00e3o sem a necessidade de dedicar recursos significativos \u00e0 administra\u00e7\u00e3o do banco de dados.</p> <p>postech-5soat-grupo-25/tech_challenge-database</p> <p>Acesse o reposit\u00f3rio para mais detalhes!</p> <p>O AWS RDS oferece v\u00e1rias vantagens que o tornam uma escolha ideal para a implementa\u00e7\u00e3o do nosso banco de dados PostgreSQL:</p> <ul> <li>Gerenciamento Simplificado: O RDS automatiza tarefas administrativas como provisionamento de hardware, configura\u00e7\u00e3o de banco de dados, patching de software e backups, permitindo que nossa equipe se concentre mais no desenvolvimento e menos na manuten\u00e7\u00e3o.</li> <li>Escalabilidade: Com o RDS, podemos facilmente escalar a capacidade de computa\u00e7\u00e3o ou armazenamento do nosso banco de dados conforme necess\u00e1rio, sem tempo de inatividade.</li> <li>Disponibilidade e Durabilidade: O RDS facilita a configura\u00e7\u00e3o de r\u00e9plicas de leitura e backups autom\u00e1ticos, garantindo alta disponibilidade e recupera\u00e7\u00e3o de desastres.</li> <li>Seguran\u00e7a: O servi\u00e7o oferece recursos robustos de seguran\u00e7a, incluindo o isolamento de rede com Amazon VPC, criptografia em tr\u00e2nsito e em repouso, e controle de acesso detalhado.</li> </ul>"},{"location":"fase_3/entregavel_1/#configuracoes-para-o-free-tier","title":"Configura\u00e7\u00f5es para o Free Tier","text":"<p>Para garantir a ader\u00eancia ao free tier da AWS e otimizar os custos, configuramos nossa inst\u00e2ncia do PostgreSQL no RDS com as seguintes especifica\u00e7\u00f5es:</p> <ul> <li>Tipo de Inst\u00e2ncia: <code>db.t3.micro</code>, adequado para ambientes de teste ou pequenas aplica\u00e7\u00f5es, e eleg\u00edvel para o free tier da AWS.</li> <li>Armazenamento Alocado: <code>10 GB</code>, dentro do limite do free tier, proporcionando espa\u00e7o suficiente para o desenvolvimento inicial e testes.</li> <li>Engine Version: Escolhemos a vers\u00e3o mais recente compat\u00edvel com o free tier para garantir melhor desempenho e seguran\u00e7a.</li> </ul>"},{"location":"fase_3/entregavel_1/#configuracoes-de-rede","title":"Configura\u00e7\u00f5es de Rede","text":"<p>Para garantir uma gest\u00e3o eficaz e segura da infraestrutura de rede que suporta o acesso ao nosso banco de dados PostgreSQL hospedado no AWS RDS, optamos por separar a configura\u00e7\u00e3o de rede em seu pr\u00f3prio reposit\u00f3rio dedicado. Essa abordagem modular nos permite focar especificamente nas necessidades de seguran\u00e7a, escalabilidade e gerenciamento da rede, facilitando a manuten\u00e7\u00e3o e a aplica\u00e7\u00e3o de melhores pr\u00e1ticas de seguran\u00e7a de forma isolada. Atrav\u00e9s deste reposit\u00f3rio de rede, implementamos uma s\u00e9rie de recursos e pol\u00edticas para gerenciar eficientemente o tr\u00e1fego de rede, permitindo o acesso seguro ao banco de dados enquanto restringimos conex\u00f5es n\u00e3o autorizadas.</p> <p>postech-5soat-grupo-25/tech_challenge-network</p> <p>Acesse o reposit\u00f3rio para mais detalhes!</p>"},{"location":"fase_3/entregavel_1/#vpc-e-sub-redes","title":"VPC e Sub-redes","text":"<ul> <li>Amazon Virtual Private Cloud (VPC): Criamos uma VPC dedicada para isolar nossa infraestrutura de banco de dados na AWS. Isso nos permite controlar o ambiente de rede, incluindo a sele\u00e7\u00e3o de intervalos de IP, cria\u00e7\u00e3o de sub-redes e configura\u00e7\u00e3o de tabelas de rotas.</li> <li>Sub-redes P\u00fablicas e Privadas: Dentro da VPC, configuramos sub-redes p\u00fablicas e privadas. O banco de dados \u00e9 colocado em sub-redes privadas para restringir o acesso direto da internet, aumentando a seguran\u00e7a.</li> </ul>"},{"location":"fase_3/entregavel_1/#grupos-de-seguranca","title":"Grupos de Seguran\u00e7a","text":"<ul> <li>Grupos de Seguran\u00e7a para o RDS: Configuramos grupos de seguran\u00e7a espec\u00edficos para o banco de dados PostgreSQL no RDS, atuando como um firewall virtual que controla o tr\u00e1fego de entrada e sa\u00edda. As regras de entrada s\u00e3o cuidadosamente definidas para permitir conex\u00f5es apenas de IPs ou sub-redes espec\u00edficas necess\u00e1rias para a opera\u00e7\u00e3o da aplica\u00e7\u00e3o, enquanto todo o tr\u00e1fego n\u00e3o autorizado \u00e9 bloqueado.</li> </ul>"},{"location":"fase_3/entregavel_1/#conectividade-segura","title":"Conectividade Segura","text":"<ul> <li>Gateway de Internet e NAT: Para permitir que o banco de dados acesse a internet para atualiza\u00e7\u00f5es e patches, sem exp\u00f4-lo diretamente, utilizamos um Gateway de Internet para as sub-redes p\u00fablicas e uma inst\u00e2ncia NAT para as sub-redes privadas. Isso garante que o banco de dados possa se comunicar com a internet de maneira segura.</li> <li>Grupos de Sub-redes do RDS: Ao associar o banco de dados a grupos de sub-redes espec\u00edficos, garantimos que ele possa operar em m\u00faltiplas zonas de disponibilidade, aumentando a disponibilidade e a resili\u00eancia.</li> </ul>"},{"location":"fase_3/entregavel_2/","title":"Entreg\u00e1vel 2","text":""},{"location":"fase_3/entregavel_2/#infraestrutura-com-terraform","title":"Infraestrutura com Terraform","text":""},{"location":"fase_3/entregavel_2/#infraestrutura-como-codigo","title":"Infraestrutura como C\u00f3digo","text":"<p>O Terraform \u00e9 uma poderosa ferramenta de c\u00f3digo aberto desenvolvida pela HashiCorp, projetada para o provisionamento e gerenciamento de infraestrutura como c\u00f3digo (IaC). Permitindo aos usu\u00e1rios definir infraestrutura em configura\u00e7\u00f5es de alto n\u00edvel, usando uma linguagem de configura\u00e7\u00e3o declarativa, o Terraform automatiza o processo de deploy de recursos em diversos provedores de servi\u00e7os em nuvem, como AWS, Google Cloud Platform e Microsoft Azure. Essa abordagem n\u00e3o apenas economiza tempo, mas tamb\u00e9m aumenta a efici\u00eancia, reduzindo o potencial de erros humanos.</p> <p>Um dos principais benef\u00edcios do Terraform \u00e9 sua capacidade de gerenciar a infraestrutura atrav\u00e9s de c\u00f3digo, o que facilita a replica\u00e7\u00e3o de ambientes, revis\u00e3o de mudan\u00e7as e rastreamento de estado da infraestrutura ao longo do tempo. Al\u00e9m disso, o Terraform promove a imutabilidade e previsibilidade nas mudan\u00e7as de infraestrutura, substituindo automaticamente os recursos alterados por novos, o que contribui significativamente para a estabilidade e seguran\u00e7a dos ambientes de TI. Essas caracter\u00edsticas tornam o Terraform uma escolha ideal para empresas que buscam adotar pr\u00e1ticas de DevOps e automa\u00e7\u00e3o de infraestrutura, garantindo um provisionamento consistente e confi\u00e1vel de recursos de TI.</p> <p>Al\u00e9m de sua flexibilidade e suporte multi-cloud, o Terraform se beneficia de uma comunidade ativa e um ecossistema rico, oferecendo uma vasta biblioteca de m\u00f3dulos reutiliz\u00e1veis que aceleram o desenvolvimento de infraestrutura. Sua integra\u00e7\u00e3o com ferramentas de CI/CD permite a automa\u00e7\u00e3o completa do ciclo de vida da infraestrutura, desde o planejamento, cria\u00e7\u00e3o, atualiza\u00e7\u00e3o at\u00e9 a destrui\u00e7\u00e3o, tornando o Terraform uma ferramenta indispens\u00e1vel para a gest\u00e3o moderna de infraestrutura em nuvem.</p>"},{"location":"fase_3/entregavel_2/#backend","title":"Backend","text":"<p>Em nosso projeto, tomamos a decis\u00e3o estrat\u00e9gica de criar um reposit\u00f3rio dedicado para o deploy do backend do Terraform na AWS. Esta escolha foi motivada pela necessidade de uma solu\u00e7\u00e3o robusta e escal\u00e1vel para o gerenciamento de nossa infraestrutura como c\u00f3digo. Ao centralizar a configura\u00e7\u00e3o do backend em um reposit\u00f3rio espec\u00edfico, conseguimos melhorar a seguran\u00e7a, a colabora\u00e7\u00e3o entre a equipe e a efici\u00eancia do provisionamento de recursos.</p> <p>postech-5soat-grupo-25/tech_challenge-.tfstate</p> <p>Acesse o reposit\u00f3rio para mais detalhes!</p>"},{"location":"fase_3/entregavel_2/#amazon-s3-e-dynamodb","title":"Amazon S3 e DynamoDB","text":"<p><code>state</code></p> <p>No Terraform, o <code>state</code> \u00e9 um registro fundamental que cont\u00e9m informa\u00e7\u00f5es sobre os recursos gerenciados por ele em sua infraestrutura. Este registro \u00e9 crucial para o Terraform entender o que foi criado e como gerenciar mudan\u00e7as na infraestrutura. O state pode ser armazenado localmente, em um arquivo chamado <code>terraform.tfstate</code>, ou remotamente, em servi\u00e7os como o Amazon S3, o que facilita o compartilhamento e a colabora\u00e7\u00e3o em equipe. O armazenamento remoto do state tamb\u00e9m oferece benef\u00edcios adicionais, como versionamento, hist\u00f3rico de estados e a possibilidade de realizar backups de forma mais eficiente.</p> <p><code>lock</code></p> <p>O <code>lock</code> do state, ou bloqueio de estado, \u00e9 outro conceito importante no gerenciamento de infraestrutura com o Terraform. O bloqueio de estado previne que m\u00faltiplas pessoas ou processos modifiquem o mesmo state ao mesmo tempo, o que poderia levar a conflitos e inconsist\u00eancias. Quando o state \u00e9 armazenado remotamente, como em um bucket S3 com uma tabela DynamoDB para o lock no caso da AWS, o Terraform automaticamente bloqueia o state durante opera\u00e7\u00f5es que o modificam, garantindo que apenas uma opera\u00e7\u00e3o seja realizada por vez. Isso \u00e9 essencial para manter a integridade e a consist\u00eancia da infraestrutura gerenciada.</p> <p>Para o armazenamento do state do Terraform, optamos pelo Amazon S3 devido \u00e0 sua confiabilidade, escalabilidade e recursos avan\u00e7ados de seguran\u00e7a, como a criptografia de objetos e o controle de acesso fino atrav\u00e9s de pol\u00edticas IAM. O versionamento do bucket S3 \u00e9 utilizado para manter um hist\u00f3rico detalhado das vers\u00f5es do state, permitindo uma f\u00e1cil recupera\u00e7\u00e3o em caso de mudan\u00e7as indesejadas ou erros.</p> <p>Juntamente com o S3, escolhemos o Amazon DynamoDB para o lock do state, uma pr\u00e1tica recomendada para equipes que trabalham em ambientes de nuvem compartilhados. O DynamoDB garante que apenas uma pessoa ou processo possa modificar o state em um dado momento, prevenindo conflitos e garantindo a integridade da nossa infraestrutura. Esta combina\u00e7\u00e3o de S3 para armazenamento de state e DynamoDB para lock representa uma solu\u00e7\u00e3o de backend altamente eficaz e segura para o gerenciamento de infraestrutura com o Terraform.</p>"},{"location":"fase_3/entregavel_2/#beneficios-da-abordagem","title":"Benef\u00edcios da Abordagem","text":"<p>A escolha de um reposit\u00f3rio dedicado para o deploy do backend do Terraform, juntamente com a utiliza\u00e7\u00e3o do S3 e DynamoDB, traz uma s\u00e9rie de benef\u00edcios para o nosso projeto:</p> <ul> <li>Seguran\u00e7a Aprimorada: A utiliza\u00e7\u00e3o de pol\u00edticas IAM e criptografia AES-256 nos permite proteger nossos estados e garantir que apenas usu\u00e1rios autorizados tenham acesso.</li> <li>Colabora\u00e7\u00e3o Eficiente: Com o lock do state gerenciado pelo DynamoDB, nossa equipe pode trabalhar simultaneamente na infraestrutura sem risco de sobreposi\u00e7\u00e3o ou conflitos de mudan\u00e7as.</li> <li>Recupera\u00e7\u00e3o e Rastreabilidade: O versionamento do bucket S3 facilita o rastreamento de mudan\u00e7as e a recupera\u00e7\u00e3o de vers\u00f5es anteriores do state, essencial para a manuten\u00e7\u00e3o e auditoria da infraestrutura.</li> <li>Integra\u00e7\u00e3o com CI/CD: Nossa solu\u00e7\u00e3o de backend \u00e9 projetada para se integrar perfeitamente com pipelines de CI/CD, permitindo a automa\u00e7\u00e3o do provisionamento e atualiza\u00e7\u00e3o da infraestrutura.</li> </ul> <p>Para garantir a efici\u00eancia e a consist\u00eancia no gerenciamento do nosso backend do Terraform, implementamos pipelines de CI/CD utilizando o GitHub Actions. Ao adotar essa abordagem, estamos n\u00e3o apenas otimizando o gerenciamento da nossa infraestrutura na nuvem, mas tamb\u00e9m estabelecendo uma funda\u00e7\u00e3o s\u00f3lida para o crescimento e a escalabilidade do nosso projeto.</p>"},{"location":"fase_4/entregavel/","title":"Entreg\u00e1vel","text":""},{"location":"fase_4/entregavel/#arquitetura-de-microservicos","title":"Arquitetura de Microservi\u00e7os","text":"Arquitetura de Microservi\u00e7os"},{"location":"fase_5/entregavel_1/","title":"Entreg\u00e1vel 1","text":""},{"location":"fase_5/entregavel_1/#aplicacao-do-padrao-saga","title":"Aplica\u00e7\u00e3o do Padr\u00e3o SAGA","text":""},{"location":"fase_5/entregavel_1/#arquitetura-de-microservicos","title":"Arquitetura de Microservi\u00e7os","text":"Arquitetura de Microservi\u00e7os <p>Reposit\u00f3rios dos microservi\u00e7os que comp\u00f5em a arquitetura</p> <ul> <li><code>pedido-produto</code>: postech-5soat-grupo-25/tech-challenge-pedido-produto</li> <li><code>usuario-cliente</code>: postech-5soat-grupo-25/tech-challenge-usuario-cliente</li> <li><code>pagamento</code>: postech-5soat-grupo-25/tech-challenge-pagamento</li> <li><code>auth</code>: postech-5soat-grupo-25/tech-challenge-auth</li> </ul>"},{"location":"fase_5/entregavel_1/#saga-coreografada","title":"SAGA Coreografada","text":"<p>No gerenciamento dos status de pagamentos dos pedidos no projeto, optamos por implementar uma SAGA coreografada utilizando RabbitMQ como sistema de mensageria. Essa escolha foi baseada nas seguintes justificativas:</p> <ul> <li>Desacoplamento e Escalabilidade: A SAGA coreografada permite um desacoplamento entre os diferentes servi\u00e7os envolvidos no processo de pagamento e gest\u00e3o de pedidos. Isso facilita a escalabilidade do sistema, pois cada servi\u00e7o pode ser desenvolvido, implantado e escalado independentemente.</li> <li>Resili\u00eancia e Toler\u00e2ncia a Falhas: A coreografia permite que o sistema seja mais resiliente a falhas, j\u00e1 que os servi\u00e7os comunicam-se entre si de forma ass\u00edncrona. Caso um servi\u00e7o falhe, o restante do sistema continua funcionando e pode lidar com a falha de maneira controlada, garantindo que o sistema como um todo permane\u00e7a operacional.</li> <li>Gerenciamento de Transa\u00e7\u00f5es Distribu\u00eddas: Com a SAGA, \u00e9 poss\u00edvel gerenciar transa\u00e7\u00f5es distribu\u00eddas de maneira eficiente, garantindo que as opera\u00e7\u00f5es sejam realizadas de forma consistente mesmo em um ambiente com m\u00faltiplos servi\u00e7os. Isso \u00e9 crucial para manter a integridade dos dados, especialmente quando lidamos com pagamentos e status de pedidos.</li> <li>Flexibilidade e Manuten\u00e7\u00e3o: A abordagem coreografada oferece maior flexibilidade na adi\u00e7\u00e3o ou modifica\u00e7\u00e3o de servi\u00e7os no futuro. Se novos requisitos surgirem ou se for necess\u00e1rio adicionar novas etapas ao processo, essas altera\u00e7\u00f5es podem ser feitas com impacto m\u00ednimo no sistema existente.</li> </ul> <p>Por que escolhemos o RabbitMQ?</p> <p>O RabbitMQ foi escolhido como a solu\u00e7\u00e3o de mensageria para suportar a SAGA coreografada devido \u00e0s seguintes raz\u00f5es:</p> <ul> <li>Alta Performance e Escalabilidade: \u00e9 conhecido por sua alta performance e capacidade de escalar horizontalmente, o que \u00e9 essencial para lidar com um grande volume de mensagens e garantir que o sistema possa crescer conforme a demanda.</li> <li>Gerenciamento Eficiente de Mensagens: oferece suporte robusto para o gerenciamento de mensagens, incluindo roteamento complexo, entrega garantida e recupera\u00e7\u00e3o de falhas. Isso assegura que as mensagens sobre o status dos pedidos sejam entregues de forma confi\u00e1vel entre os servi\u00e7os.</li> <li>Suporte a Transa\u00e7\u00f5es e Persist\u00eancia: permite a persist\u00eancia de mensagens e o suporte a transa\u00e7\u00f5es, o que \u00e9 vital para garantir que as mensagens sobre o status dos pedidos n\u00e3o sejam perdidas, mesmo em caso de falhas no sistema.</li> <li>Integra\u00e7\u00e3o e Compatibilidade: \u00e9 altamente compat\u00edvel com uma variedade de linguagens e frameworks, facilitando a integra\u00e7\u00e3o com diferentes componentes do sistema e permitindo que os servi\u00e7os de diferentes stacks tecnol\u00f3gicos se comuniquem de forma eficiente.</li> </ul> <p>A combina\u00e7\u00e3o da SAGA coreografada com RabbitMQ proporciona um ambiente robusto e flex\u00edvel para o gerenciamento dos status de pagamentos e pedidos. Essa abordagem n\u00e3o apenas melhora a escalabilidade e a resili\u00eancia do sistema, mas tamb\u00e9m oferece a flexibilidade necess\u00e1ria para atender \u00e0s necessidades em constante evolu\u00e7\u00e3o do projeto. A escolha dessas tecnologias reflete um compromisso com a efici\u00eancia operacional e a capacidade de lidar com as complexidades de um sistema distribu\u00eddo moderno.</p>"},{"location":"fase_5/entregavel_2/","title":"Entreg\u00e1vel 2","text":""},{"location":"fase_5/entregavel_2/#lei-geral-de-protecao-de-dados-lgpd","title":"Lei Geral de Prote\u00e7\u00e3o de Dados (LGPD)","text":""},{"location":"fase_5/entregavel_2/#solicitacao-de-exclusao-de-dados-pessoais","title":"Solicita\u00e7\u00e3o de Exclus\u00e3o de Dados Pessoais","text":"/solicitacao/exclusao/ <p>Cadastra uma nova solicita\u00e7\u00e3o de exclus\u00e3o de dados pessoais do cliente.</p> Par\u00e2metro Tipo Descri\u00e7\u00e3o nome <code>string</code> Nome do cliente. endereco <code>string</code> Endere\u00e7o do cliente. telefone <code>string</code> Telefone do cliente. <p>Decidimos criar um microservi\u00e7o dedicado para gerenciar a solicita\u00e7\u00e3o de exclus\u00e3o de dados pessoais, em vez de adicionar um endpoint ao microservi\u00e7o existente de opera\u00e7\u00f5es <code>usuario-cliente</code>. Esta decis\u00e3o foi tomada com base nos seguintes argumentos:</p> <p>Isolamento de Responsabilidade: Separar a funcionalidade de exclus\u00e3o de dados pessoais da opera\u00e7\u00e3o cr\u00edtica evita que mudan\u00e7as ou problemas relacionados a essa fun\u00e7\u00e3o espec\u00edfica afetem o funcionamento do microservi\u00e7o principal de opera\u00e7\u00f5es. Isso segue o princ\u00edpio de responsabilidade \u00fanica, mantendo cada servi\u00e7o focado em sua fun\u00e7\u00e3o principal.</p> <p>Seguran\u00e7a e Conformidade: A exclus\u00e3o de dados pessoais \u00e9 uma opera\u00e7\u00e3o sens\u00edvel e est\u00e1 diretamente relacionada \u00e0 conformidade com a LGPD. Isolar essa funcionalidade em um servi\u00e7o dedicado permite a aplica\u00e7\u00e3o de controles de seguran\u00e7a espec\u00edficos e facilita a auditoria, sem impactar outras partes do sistema.</p> <p>Escalabilidade Independente: Um microservi\u00e7o dedicado pode ser escalado de forma independente, permitindo ajustes na capacidade de acordo com a demanda por exclus\u00f5es de dados, sem afetar as opera\u00e7\u00f5es essenciais do servi\u00e7o principal.</p> <p>Facilidade de Manuten\u00e7\u00e3o e Evolu\u00e7\u00e3o: Manter a exclus\u00e3o de dados em um servi\u00e7o dedicado facilita sua manuten\u00e7\u00e3o e a implementa\u00e7\u00e3o de futuras melhorias ou altera\u00e7\u00f5es na l\u00f3gica de neg\u00f3cio, sem arriscar efeitos colaterais nas opera\u00e7\u00f5es cr\u00edticas do microservi\u00e7o de opera\u00e7\u00e3o.</p> <p>Desacoplamento de Funcionalidades: Desacoplar a funcionalidade de exclus\u00e3o de dados pessoais permite que o microservi\u00e7o de opera\u00e7\u00e3o <code>usuario-cliente</code> mantenha seu ciclo de vida independente de mudan\u00e7as regulat\u00f3rias ou exig\u00eancias espec\u00edficas relacionadas \u00e0 prote\u00e7\u00e3o de dados.</p> <p>Al\u00e9m dos benef\u00edcios mencionados anteriormente, a cria\u00e7\u00e3o de um microservi\u00e7o dedicado tamb\u00e9m nos proporcionou a oportunidade de explorar uma nova linguagem e tecnologia para o desenvolvimento. Em um ambiente corporativo real, \u00e9 comum que diferentes times adotem stacks tecnol\u00f3gicas distintas, refletindo a diversidade de especializa\u00e7\u00f5es e prefer\u00eancias.</p> <p>postech-5soat-grupo-25/tech-challenge-lgpd</p> <p>Acesse o reposit\u00f3rio para mais detalhes!</p>"},{"location":"fase_5/entregavel_2/#relatorio-de-impacto-a-protecao-de-dados-pessoais-ripd","title":"Relat\u00f3rio de Impacto \u00e0 Prote\u00e7\u00e3o de Dados Pessoais (RIPD)","text":""},{"location":"fase_5/entregavel_3/","title":"Entreg\u00e1vel 3","text":""},{"location":"fase_5/entregavel_3/#relatorios-de-vulnerabilidade-owasp-zap","title":"Relat\u00f3rios de Vulnerabilidade OWASP Zap","text":""},{"location":"fase_5/entregavel_3/#antes","title":"Antes","text":""},{"location":"fase_5/entregavel_3/#microservico-pedido-produto","title":"Microservi\u00e7o <code>pedido-produto</code>","text":""},{"location":"fase_5/entregavel_3/#microservico-pagamento","title":"Microservi\u00e7o <code>pagamento</code>","text":""},{"location":"fase_5/entregavel_3/#depois","title":"Depois","text":"<p>N\u00e3o foram identificadas vulnerabilidades altas para nenhum dos fluxos analisados com a ferramenta, ent\u00e3o n\u00e3o foi necess\u00e1rio aplicar corre\u00e7\u00f5es.</p>"},{"location":"hackathon/entregavel/","title":"Entreg\u00e1vel","text":""},{"location":"hackathon/entregavel/#healthmed","title":"Health&amp;Med","text":""},{"location":"hackathon/entregavel/#gerenciador-de-consultas","title":"Gerenciador de Consultas","text":"<p>O objetivo desse projeto \u00e9 solucionar um gargalo operacional enfrentado pela Health&amp;Med, uma operadora de sa\u00fade que ainda realiza agendamentos de consultas exclusivamente por telefone. Esse processo manual resulta em baixa efici\u00eancia, dificuldades na gest\u00e3o de hor\u00e1rios, e insatisfa\u00e7\u00e3o tanto para m\u00e9dicos quanto para pacientes. Para otimizar esse fluxo, desenvolvemos um sistema 100% digital que automatiza o processo de agendamento e cadastro de usu\u00e1rios.</p> <p>O principal problema identificado pela Health&amp;Med \u00e9 o processo manual de agendamento de consultas m\u00e9dicas. Atualmente, os pacientes precisam ligar para uma central de atendimento, o que cria um gargalo no processo, causando atrasos e reduzindo a satisfa\u00e7\u00e3o do cliente. Al\u00e9m disso, a gest\u00e3o de hor\u00e1rios de m\u00e9dicos e a valida\u00e7\u00e3o de conflitos de agenda n\u00e3o s\u00e3o bem gerenciadas. Com o crescimento da empresa, esse problema tende a piorar, comprometendo ainda mais a opera\u00e7\u00e3o.</p> <p>Diante desses desafios, optamos por uma abordagem baseada na separa\u00e7\u00e3o das responsabilidades em dois servi\u00e7os: <code>usuarios</code> e <code>agendamento</code>.</p>"},{"location":"hackathon/entregavel/#servico-de-usuarios","title":"Servi\u00e7o de <code>usuarios</code>","text":"<p>\u00c9 respons\u00e1vel por gerenciar o cadastro e a autentica\u00e7\u00e3o de m\u00e9dicos e pacientes. Ele oferece funcionalidades essenciais, como registro de novos usu\u00e1rios, atualiza\u00e7\u00e3o de informa\u00e7\u00f5es pessoais e, embora n\u00e3o implemente um sistema de login tradicional, assegura a cria\u00e7\u00e3o de perfis seguros para cada usu\u00e1rio. O servi\u00e7o inclui tamb\u00e9m valida\u00e7\u00f5es rigorosas e medidas de seguran\u00e7a para proteger dados pessoais sens\u00edveis, garantindo que as informa\u00e7\u00f5es dos usu\u00e1rios estejam sempre seguras e acess\u00edveis apenas a eles.</p> <p>TypeScript</p> <p>O servi\u00e7o foi projetado para gerenciar o cadastro e a classifica\u00e7\u00e3o de diferentes tipos de usu\u00e1rios dentro do sistema, utilizando TypeScript. Ao focar exclusivamente no processo de cadastro, este servi\u00e7o garante uma abordagem simplificada e eficaz para a cria\u00e7\u00e3o de perfis de usu\u00e1rio. Cada tipo de usu\u00e1rio possui atributos e caracter\u00edsticas espec\u00edficas que s\u00e3o gerenciados de forma centralizada, permitindo uma organiza\u00e7\u00e3o clara das informa\u00e7\u00f5es e facilitando futuras expans\u00f5es. Essa separa\u00e7\u00e3o de responsabilidades permite que o servi\u00e7o de usu\u00e1rios se concentre em sua fun\u00e7\u00e3o principal, otimizando a manuten\u00e7\u00e3o e a escalabilidade do sistema como um todo.</p> <p>postech-5soat-grupo-25/hackathon-usuarios</p> <p>Acesse o reposit\u00f3rio para mais detalhes!</p>"},{"location":"hackathon/entregavel/#servico-de-agendamento","title":"Servi\u00e7o de <code>agendamento</code>","text":"<p>\u00c9 respons\u00e1vel pela gest\u00e3o eficiente de hor\u00e1rios e consultas. Este servi\u00e7o permite que m\u00e9dicos configurem sua disponibilidade para atendimentos, enquanto os pacientes podem agendar consultas com base nos hor\u00e1rios dispon\u00edveis. Para evitar conflitos de hor\u00e1rios, o servi\u00e7o implementa uma l\u00f3gica robusta que assegura que n\u00e3o haja sobreposi\u00e7\u00e3o de consultas. Al\u00e9m disso, ap\u00f3s cada agendamento, um e-mail de notifica\u00e7\u00e3o \u00e9 enviado ao m\u00e9dico, contendo todos os detalhes da consulta marcada, mantendo todos os envolvidos informados e organizados.</p> <p>Go</p> <p>A implementa\u00e7\u00e3o em Go foi escolhida devido \u00e0 sua capacidade de manipular opera\u00e7\u00f5es concorrentes atrav\u00e9s das goroutines. Essa caracter\u00edstica permite que o servi\u00e7o gerencie m\u00faltiplas requisi\u00e7\u00f5es de agendamento de forma eficiente, garantindo que a aplica\u00e7\u00e3o permane\u00e7a responsiva mesmo em situa\u00e7\u00f5es de alta demanda. A utiliza\u00e7\u00e3o do Go tamb\u00e9m proporciona um desempenho robusto, ideal para opera\u00e7\u00f5es que exigem rapidez e efici\u00eancia. Al\u00e9m disso, a estrutura simples do Go facilita a implementa\u00e7\u00e3o de l\u00f3gica de agendamento, contribuindo para um sistema mais \u00e1gil e menos suscet\u00edvel a falhas.</p> <p>postech-5soat-grupo-25/hackathon-agendamento</p> <p>Acesse o reposit\u00f3rio para mais detalhes!</p> <p>A decis\u00e3o de separar o sistema em dois servi\u00e7os surgiu da necessidade de manter uma clara divis\u00e3o de responsabilidades, facilitando a escalabilidade e manuten\u00e7\u00e3o do sistema no futuro. Com isso, conseguimos isolar as funcionalidades principais, permitindo que altera\u00e7\u00f5es em uma parte do sistema de cadastro de usu\u00e1rios n\u00e3o impactem diretamente no servi\u00e7o de agendamento, e vice-versa.</p>"},{"location":"hackathon/entregavel/#infraestrutura","title":"Infraestrutura","text":"<p>A infraestrutura do projeto \u00e9 constru\u00edda sobre os princ\u00edpios da escalabilidade e resili\u00eancia, aproveitando os servi\u00e7os da AWS para garantir uma opera\u00e7\u00e3o eficiente e segura. No cora\u00e7\u00e3o da arquitetura, o Elastic Container Service (ECS) \u00e9 utilizado para orquestrar os containers que hospedam os servi\u00e7os de usu\u00e1rios e agendamento. Essa escolha permite o gerenciamento simplificado dos ambientes de execu\u00e7\u00e3o, al\u00e9m de facilitar a implanta\u00e7\u00e3o e o escalonamento autom\u00e1tico conforme a demanda dos usu\u00e1rios.</p> <p>Para garantir a alta disponibilidade e distribuir a carga de trabalho, um Elastic Load Balancer (ELB) \u00e9 integrado \u00e0 solu\u00e7\u00e3o. O ELB atua como um ponto de entrada para as requisi\u00e7\u00f5es, direcionando-as de maneira eficiente entre as inst\u00e2ncias do ECS, garantindo que o tr\u00e1fego seja distribu\u00eddo de forma equilibrada e que os servi\u00e7os permane\u00e7am acess\u00edveis mesmo em caso de falhas em algumas inst\u00e2ncias. Essa configura\u00e7\u00e3o n\u00e3o apenas melhora a performance, mas tamb\u00e9m contribui para a resili\u00eancia geral da aplica\u00e7\u00e3o.</p> <p>O Amazon API Gateway \u00e9 utilizado como um intermedi\u00e1rio para gerenciar as requisi\u00e7\u00f5es entre os clientes e os servi\u00e7os de backend. Ele permite a defini\u00e7\u00e3o de rotas e m\u00e9todos HTTP, facilitando a implementa\u00e7\u00e3o de endpoints para opera\u00e7\u00f5es como agendamento e envio de e-mails. O API Gateway oferece recursos como autentica\u00e7\u00e3o, controle de acesso e monitoramento, tornando-se uma pe\u00e7a fundamental na seguran\u00e7a e na gest\u00e3o das intera\u00e7\u00f5es entre usu\u00e1rios e servi\u00e7os.</p> <p>Adicionalmente, o projeto utiliza AWS Cognito para gerenciar a autentica\u00e7\u00e3o de usu\u00e1rios, permitindo que m\u00e9dicos e pacientes tenham um acesso seguro e controlado \u00e0 aplica\u00e7\u00e3o. A integra\u00e7\u00e3o com o Amazon Simple Email Service (SES) \u00e9 implementada para enviar notifica\u00e7\u00f5es e confirma\u00e7\u00f5es de agendamentos, assegurando que a comunica\u00e7\u00e3o entre a aplica\u00e7\u00e3o e os usu\u00e1rios seja clara e eficaz.</p> <p>Em termos de infraestrutura como c\u00f3digo, o Terraform \u00e9 empregado para automatizar a cria\u00e7\u00e3o e o gerenciamento dos recursos da AWS, promovendo a consist\u00eancia e a reusabilidade da infraestrutura. Com essa abordagem, a equipe pode rapidamente implementar mudan\u00e7as e escalar a solu\u00e7\u00e3o conforme necess\u00e1rio, garantindo uma base s\u00f3lida para o crescimento futuro.</p> <p>As funcionalidades de login e envio de e-mails foram posicionadas pr\u00f3ximas ao API Gateway, evitando a necessidade de um servi\u00e7o dedicado para essas opera\u00e7\u00f5es simples. Essa abordagem simplifica a intera\u00e7\u00e3o entre o frontend e o backend, utilizando solu\u00e7\u00f5es nativas da AWS para autentica\u00e7\u00e3o e comunica\u00e7\u00e3o. A escolha de implementar o login com a integra\u00e7\u00e3o ao Cognito permite uma gest\u00e3o segura dos usu\u00e1rios, enquanto o envio de e-mails \u00e9 tratado atrav\u00e9s do SES, garantindo que as notifica\u00e7\u00f5es de agendamentos sejam enviadas de forma confi\u00e1vel e em tempo h\u00e1bil. Essa estrutura n\u00e3o s\u00f3 melhora a efici\u00eancia do sistema, mas tamb\u00e9m proporciona uma experi\u00eancia de usu\u00e1rio fluida e direta.</p> <p>postech-5soat-grupo-25/hackathon-infra</p> <p>Acesse o reposit\u00f3rio para mais detalhes!</p> <p>Abaixo temos um exemplo de e-mail enviado pela solu\u00e7\u00e3o:</p> <p> </p>"}]}